<!DOCTYPE html><html lang="zh-CN"><head> <meta name="author" content="åŠ±å°åŠ "> <meta name="copyright" content="Â© 2025 åŠ±å°åŠ "><meta name="license" content="GPL-3.0"> <meta name="generator" content="æ­£åé¦ˆæˆé•¿åŠ©æ‰‹"> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>æ­£åé¦ˆæˆé•¿åŠ©æ‰‹</title> <style> :root { --primary: #4CAF50; --secondary: #2196F3; --accent: #FF9800; --light: #f5f5f5; --dark: #333; --danger: #f4634b; --success: #4CAF50; --collapse: #74b9ff; } * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } body { background-color: #f0f2f5; color: var(--dark); line-height: 1.6; font-size: 16px; } .container { max-width: 800px; margin: 0 auto; padding: 15px; } .header-controls { display: none; transition: all 0.3s ease; } .header-controls.visible { display: block; } .btn-export { background-color: #2196F3; } .btn-import { background-color: #2196F3; } .btn-reminder { background-color: #FF9800; } .btn-reset { background-color: #f44336; } .import-categories { font-size: 0.8rem; line-height: 1.2; } .import-category-section { margin-bottom: 0; } .import-category-section label { margin-bottom: 0; } #import-achievements-details, #import-skills-details, #import-reflections-details, #import-value-details { font-size: 0.8rem; line-height: 1; } .import-category-section label span { font-size: 0.75rem; } .export-options { margin: 8px 0; } .export-options h4 { margin-bottom: 4px; font-size: 0.9rem; } .date-range-inputs { gap: 3px; margin-bottom: 6px; display: flex; } .export-categories { gap: 3px; margin: 3px 0; } .export-preview { margin-top: 5px; } .export-preview h4 { margin-bottom: 3px; } header { text-align: center; margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: all 0.3s ease; cursor: pointer; } header.reminder { background: linear-gradient(135deg, #f44336, #FF9800); } header h1 { font-size: 1.5rem; } header p { font-size: 0.9rem; } .nav-tabs { display: flex; justify-content: space-around; margin-bottom: 15px; background: white; border-radius: 10px; padding: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-wrap: wrap; } .tab { padding: 8px 12px; cursor: pointer; border-radius: 5px; transition: all 0.3s ease; margin: 2px; text-align: center; flex: 1; min-width: 0; background-color: white; color: var(--dark); } .tab.active { background-color: var(--primary); color: white; } .tab-content { display: none; background: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } .tab-content.active { display: block; } .achievement-item, .skill-item, .value-item, .reflection-item { background: var(--light); padding: 12px; margin: 5px 0; border-radius: 8px; border-left: 4px solid var(--primary); } .achievement-date { font-weight: bold; margin-top: 4px; color: var(--dark); display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-radius: 5px; }.achievement-date span { display: inline-block; white-space: nowrap;}.achievement-date span .highlight { display: inline;} .collapse-icon { font-size: 1.2rem; transition: transform 0.3s; } .collapsed .collapse-icon { transform: rotate(-90deg); } .collapsible-content { overflow: hidden; transition: max-height 0.3s ease; } .collapsed .collapsible-content { max-height: 0; } .achievement-list { margin-left: 8px; margin-top: 2px; } .achievement-entry { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e0e0e0; gap: 8px; padding: 3px 0; } .achievement-entry:last-child { border-bottom: none; } .achievement-text { flex-grow: 1; margin-right: 8px; word-break: break-word; line-height: 1.4; font-size: 0.9rem; } .reflection-text, .checkin-text, .value-text { white-space: pre-wrap; } .achievement-time { font-style: italic; color: #888; font-size: 0.8rem; margin-left: 5px; } .modification-history { font-size: 0.7rem; color: #666; margin-top: 8px; padding-left: 8px; border-left: 2px solid #ddd; line-height: 1.3; } .input-group { margin-bottom: 12px; display: flex; gap: 8px; } input, textarea, select { flex: 1; padding: 10px; margin: 4px 0; border: 1px solid #ddd; border-radius: 5px; font-size: 14px; } textarea { resize: vertical; min-height: 80px; } button { background-color: var(--primary); color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; white-space: nowrap; font-size: 14px; } .btn-danger, .btn-edit { margin-top: 5px; margin-bottom: 10px; } .btn-danger { background-color: var(--danger); } .btn-edit { background-color: #d689f4; } .btn-collapse { background-color: var(--collapse); margin-top: 3px; } #reset-modal .action-buttons button { margin-bottom: 0; padding: 10px 15px; font-size: 14px; } .progress-bar { height: 18px; background-color: #e0e0e0; border-radius: 10px; margin: 2px 0; overflow: hidden; margin-top: 3px; } .progress { height: 100%; background-color: var(--primary); border-radius: 10px; transition: width 0.5s ease; } .stats { display: flex; justify-content: space-around; text-align: center; margin: 15px 0; } .stat-item { flex: 1; padding: 8px; } .stat-value { font-size: 24px; font-weight: bold; color: var(--primary); } .stat-item div:last-child { font-size: 0.85rem; } .empty-state { text-align: center; padding: 15px; color: #777; font-size: 0.9rem; } .skill-controls { display: flex; gap: 5px; margin-top: 8px; flex-wrap: wrap; } .skill-controls button { padding: 6px 10px; font-size: 13px; } .skill-category-label { cursor: pointer; transition: all 0.2s ease; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; font-weight: bold; margin-left: 8px; display: inline-block; } .skill-category-label:hover { transform: scale(1.05); box-shadow: 0 2px 4px rgba(0,0,0,0.2); } .achievement-controls { display: flex; gap: 5px; flex-shrink: 0; align-items: flex-start; } .achievement-controls button { padding: 5px 8px; font-size: 12px; } .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1001; justify-content: center; align-items: center; padding: 15px; } .modal-content { background-color: white; padding: 15px; border-radius: 10px; width: 100%; max-width: 500px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); max-height: 90vh; overflow-y: auto; } .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; } .modal-close { background: none; border: none; font-size: 20px; cursor: pointer; color: #777; } .modal-content textarea, .modal-content input { width: 100%; box-sizing: border-box; } .utility-buttons { display: flex; justify-content: center; gap: 8px; margin: 15px 0; flex-wrap: wrap; } .utility-buttons button { padding: 8px 12px; font-size: 0.85rem; } .checkin-content { margin-top: 8px; } .action-buttons { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; } .streak-milestone { color: var(--accent); font-weight: bold; margin-top: 4px; font-size: 0.8rem; } .value-category { background: white; padding: 12px; margin: 8px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } .value-category h3 { margin-bottom: 8px; color: var(--primary); font-size: 1.1rem; } .value-category p { margin-bottom: 12px; color: #555; font-size: 0.9rem; } .skill-header, .value-output-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; cursor: pointer; padding: 8px; border-radius: 5px; transition: background-color 0.3s; } .skill-header h3, .value-output-header h3 { margin: 0; flex-grow: 1; font-size: 1.1rem; } .skill-header-controls, .value-output-header-controls { display: flex; gap: 2px; } .skill-header-controls button, .value-output-header-controls button { padding: 3px 8px; font-size: 12px; } .value-output-item { background: var(--light); padding: 12px; margin: 5px 0; border-radius: 8px; border-left: 4px solid var(--primary); } .value-output-header { margin-bottom: 8px; } .value-category-buttons { display: flex; flex-wrap: nowrap; gap: 2px; margin: 5px 0; } .value-category-button { flex: 1; min-width: 0px; background-color: white; color: var(--dark); padding: 10px 4px; text-align: center; border-radius: 8px; cursor: pointer; border: 1px solid #ddd; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: all 0.3s ease; } .value-category-button.active { background-color: var(--primary); color: white; flex: 2; min-width: 80px; } @media (min-width: 601px) { .value-category-button.active { flex: 1; } } .value-input-area { display: none; background: white; padding: 12px; margin: 8px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } .value-input-area.active { display: block; } .search-container { margin: 15px 0; display: flex; gap: 8px; align-items: center; } .search-input-wrapper { position: relative; flex: 1; min-width: 200px; } .search-container input { width: 100%; padding-right: 35px; } .search-clear { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 18px; cursor: pointer; color: #999; display: flex; align-items: center; justify-content: center; width: 20px; height: 20px; border-radius: 50%; } .search-clear:hover { background-color: #f0f0f0; color: #666; } .collapse-controls { display: flex; justify-content: flex-end; margin-bottom: 10px; gap: 8px; } .highlight { background-color: #ffeb3b; border-radius: 2px; } .calendar-button { background-color: var(--accent); } .date-filter-tabs { display: flex; margin-bottom: 15px; border-bottom: 1px solid #ddd; } .date-filter-tab { padding: 8px 15px; cursor: pointer; border-bottom: 2px solid transparent; } .date-filter-tab.active { border-bottom: 2px solid var(--primary); color: var(--primary); } .date-filter-content { display: none; padding: 10px 0; } .date-filter-content.active { display: block; } .calendar-container { max-height: 300px; overflow-y: auto; margin-top: 10px; } .calendar-month { margin-bottom: 15px; } .calendar-month-header { text-align: center; padding: 5px; background-color: var(--light); border-radius: 5px; margin-bottom: 5px; font-weight: bold; } .calendar-weekdays { display: grid; grid-template-columns: repeat(7, 1fr); text-align: center; font-weight: bold; margin-bottom: 5px; } .calendar-days { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; } .calendar-day { text-align: center; padding: 5px; border-radius: 3px; cursor: pointer; } .calendar-day.recorded { background-color: var(--primary); color: white; } .calendar-day.selected { background-color: var(--accent); color: white; } .calendar-day:hover { background-color: #e0e0e0; } .calendar-day.empty { background-color: transparent; cursor: default; } .export-options { margin: 15px 0; } .export-options h4 { margin-bottom: 8px; color: var(--dark); } .export-categories { display: flex; flex-direction: column; gap: 8px; margin: 10px 0; } .export-category-label { display: flex; align-items: center; gap: 8px; cursor: pointer; } .export-preview { margin-top: 15px; } .export-preview textarea { width: 100%; min-height: 150px; margin-top: 8px; } .import-results { max-height: 200px; overflow-y: auto; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px; padding: 10px; background-color: var(--light); } .import-result-item { padding: 5px 0; border-bottom: 1px solid #e0e0e0; } .import-result-item:last-child { border-bottom: none; } .import-success { color: var(--success); } .import-failure { color: var(--danger); } .password-input { width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px; font-size: 16px; } .password-error { color: var(--danger); font-size: 0.9rem; margin-top: 5px; display: none; } .skill-category-buttons { display: flex; flex-wrap: wrap; gap: 8px; margin: 15px 0; } .skill-category-button { flex: 1; min-width: 120px; background-color: white; color: var(--dark); padding: 10px 12px; text-align: center; border-radius: 8px; cursor: pointer; border: 1px solid #ddd; } .skill-category-button.active { background-color: var(--primary); color: white; } .skill-category-selector { display: flex; gap: 5px; margin-top: 8px; } .skill-category-selector select { flex: 1; padding: 6px 8px; font-size: 14px; } .skill-category-completed { border-left: 4px solid var(--success); } .skill-category-focus { border-left: 4px solid var(--accent); } .skill-category-want { border-left: 4px solid var(--secondary); } .category-completed { background-color: var(--success); color: white; } .category-focus { background-color: var(--accent); color: white; } .category-want { background-color: var(--secondary); color: white; } .reflection-title { font-weight: bold; margin-top: 10px; color: var(--primary); font-size: 1rem; } .skill-action-modal { text-align: center; } .skill-action-buttons { display: flex; flex-direction: column; gap: 10px; margin: 20px 0; } .skill-action-buttons button { padding: 12px; font-size: 16px; } .existing-skills-list { max-height: 200px; overflow-y: auto; margin: 15px 0; border: 1px solid #ddd; border-radius: 5px; } .existing-skill-item { padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; transition: background-color 0.2s; } .existing-skill-item:hover { background-color: #f5f5f5; } .existing-skill-item:last-child { border-bottom: none; } .reflection-content { max-height: 200px; overflow-y: auto; border-bottom: 1px solid #e0e0e0; border-radius: 5px; } .value-output-content { max-height: 200px; overflow-y: auto; border-bottom: 1px solid #e0e0e0; } .reminder-options { margin: 15px 0; } .reminder-options h4 { margin-bottom: 8px; color: var(--dark); } .reminder-type { display: flex; gap: 15px; margin-bottom: 15px; } .reminder-type label { display: flex; align-items: center; gap: 5px; cursor: pointer; } .reminder-details { margin-top: 10px; } .reminder-details select { margin: 5px 0; width: 100%; } .reflection-meta { margin-top: 10px; padding: 5px; } .value-output-entry { margin-bottom: 3px; }.value-output-meta .modification-history { background: #f5f5f5; border-radius: 4px; font-size: 0.8rem;} label { display: flex; align-items: center; justify-content: space-between; cursor: pointer; } .preview-format-btn { padding: 6px 12px; border: 1px solid #ddd; background: white; color: #333; border-radius: 4px; cursor: pointer; transition: all 0.3s ease; } .preview-format-btn.active { background-color: var(--primary); color: white; border-color: var(--primary); } .preview-format-btn:hover:not(.active) { background-color: #f5f5f5; } @media (min-width: 601px) and (max-width: 1024px) { .container { padding: 20px; } .tab { padding: 10px 15px; } } @media (max-width: 600px) { .tab-content h2 { font-size: 1.2rem; line-height: 1.2; margin-bottom: 5px; } .tab-content > p { font-size: 0.95rem; line-height: 1.2; margin-bottom: 5px; } .value-input-area h3 { font-size: 1.1rem; line-height: 1.3; } .value-input-area > p { font-size: 0.9rem; line-height: 1.2; margin-bottom: 3px; } .date-range-inputs { flex-direction: row !important; flex-wrap: nowrap !important; gap: 5px; align-items: center; } .date-range-inputs input { flex: 1; min-width: 0; font-size: 14px; } .date-range-inputs span { white-space: nowrap; flex-shrink: 0; } .export-options .date-range-inputs { display: flex; flex-direction: row; align-items: center; } .container { padding: 10px; } header { padding: 12px; margin-bottom: 15px; } header h1 { font-size: 1.3rem; } .nav-tabs { flex-direction: row; padding: 5px; justify-content: space-between; gap: 0; } .tab { flex: 1; min-width: 0; padding: 8px 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.85rem; margin: 0; } .input-group { flex-direction: column; } .skill-controls { flex-wrap: wrap; } .achievement-entry { flex-direction: column; align-items: flex-start; } .achievement-text { margin-right: 0; margin-bottom: 5px; } .achievement-controls { width: 100%; justify-content: flex-end; } .utility-buttons { flex-direction: row; justify-content: center; } .utility-buttons button { min-width: auto; font-size: 0.9rem; padding: 8px 10px; margin: 2px; } .action-buttons { flex-direction: row; } .action-buttons button { width: auto; } .skill-header, .value-output-header { flex-direction: column; align-items: flex-start; } .skill-header-controls, .value-output-header-controls { margin-top: 8px; width: 100%; justify-content: flex-end; } .value-category-buttons { flex-wrap: nowrap; gap: 1px; } .value-category-button { padding: 8px 2px; font-size: 0.85rem; min-width: 60px; } .value-category-button.active { flex: 3; min-width: 100px; } .stats { margin: 10px 0; } .stat-value { font-size: 18px; } .stat-item div:last-child { font-size: 0.8rem; } .modal-content { padding: 12px; } textarea { min-height: 60px; } .date-range-inputs { flex-direction: column; } .date-filter-tabs { flex-wrap: wrap; } .date-filter-tab { padding: 6px 10px; font-size: 0.85rem; } .skill-category-buttons { flex-direction: row; gap: 0; } .skill-category-button { flex: 1; min-width: 0; padding: 10px 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.85rem; margin: 1px; } .search-input-wrapper { min-width: 150px; } .reflection-content, .value-output-content { max-height: 150px; } } @media (max-width: 380px) { h2 { font-size: 1.2rem; } .tab { font-size: 0.8rem; padding: 7px 4px; } .utility-buttons button { font-size: 0.85rem; padding: 7px 8px; } .value-category-button { font-size: 0.75rem; padding: 8px 4px; } .skill-category-button { font-size: 0.75rem; padding: 8px 4px; } .search-input-wrapper { min-width: 120px; } }@media (max-width: 600px) { .reflection-buttons-container { flex-direction: row;display: flex; width: 100%;gap: 2px; } .reflection-buttons-container button { flex: 1; }}#privacy-modal .modal-content { border: 2px solid #4CAF50; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);max-width: 450px; padding: 15px;} </style> </head><body><div id="privacy-modal" class="modal" style="display: none;"> <div class="modal-content"> <div class="modal-header"> <h3>é‡è¦å£°æ˜ä¸ä½¿ç”¨é¡»çŸ¥</h3> </div> <div style="max-height: 400px; overflow-y: auto; line-height: 1.6;"> <h4 style="margin-top: 0px;">âš ï¸ å…è´£å£°æ˜</h4> <p>1. æœ¬å·¥å…·ä¸º<strong>å…è´¹çš„ä¸ªäººæˆé•¿è¾…åŠ©å·¥å…·</strong>ï¼Œä¸æä¾›ä»»ä½•å½¢å¼çš„æ‹…ä¿</p> <p>2. <strong>ä¸é€‚åˆäººç¾¤</strong>ï¼šå®¹æ˜“äº§ç”Ÿå¼ºè¿«è¡Œä¸ºå’Œæœ‰ä¸¥é‡å¿ƒç†é—®é¢˜è€…</p> <p>3. å¼€å‘è€…<strong>ä¸å¯¹ä»»ä½•ç›´æ¥æˆ–é—´æ¥æŸå¤±è´Ÿè´£</strong></p> <h4>ğŸ”’ æ•°æ®å®‰å…¨</h4> <p>â€¢ æ‰€æœ‰æ•°æ®<strong>ä»…å­˜å‚¨åœ¨æµè§ˆå™¨æœ¬åœ°</strong>ï¼Œä¸ä¼šä¸Šä¼ åˆ°ä»»ä½•æœåŠ¡å™¨</p> <p>â€¢ è¯·åŠ¡å¿…<strong>å®šæœŸä½¿ç”¨å¯¼å‡ºåŠŸèƒ½å¤‡ä»½æ•°æ®</strong>ï¼Œé˜²æ­¢æ„å¤–ä¸¢å¤±</p> <p>â€¢ æ¸…é™¤æµè§ˆå™¨æˆ–è®¾å¤‡æ•°æ®ä¼šå¯¼è‡´<strong>æ‰€æœ‰è®°å½•æ°¸ä¹…ä¸¢å¤±</strong></p> <h4>â¤ï¸ å¥åº·ä½¿ç”¨å»ºè®®</h4> <p>â€¢ æ¯å¤©è®°å½•3-5ä»¶å°äº‹å³å¯ï¼Œ<strong>ä¸è¦å¼ºæ±‚å®Œç¾è®°å½•</strong></p> <p>â€¢ å…³æ³¨è¿›æ­¥è€Œéä¸è¶³ï¼Œ<strong>åº†ç¥æ¯ä¸€ä¸ªå°æˆå°±</strong></p> <p>â€¢ å¦‚æœè®°å½•è®©ä½ æ„Ÿåˆ°å‹åŠ›ï¼Œ<strong>ç«‹å³å‡å°‘é¢‘ç‡æˆ–æš‚åœä½¿ç”¨</strong></p> <p>â€¢ æœ¬å·¥å…·<strong>ä¸èƒ½æ›¿ä»£ä¸“ä¸šå¿ƒç†å’¨è¯¢æˆ–æ²»ç–—</strong></p> </div> <div class="action-buttons"> <button onclick="acceptPrivacy()" style="background-color: #4CAF50;">æˆ‘ç†è§£å¹¶åŒæ„ä»¥ä¸Šæ¡æ¬¾</button> </div> </div></div> <div class="container"> <header id="main-header" onclick="toggleHeaderControls()" style="cursor: pointer;"> <h1>æ­£åé¦ˆæˆé•¿åŠ©æ‰‹</h1> <div class="slogan-container"> <p id="random-slogan" class="slogan-item"></p> </div> </header> <div class="header-controls"> <div class="utility-buttons"> <button class="btn-export" onclick="showEnhancedExportModal()">å¯¼å‡º</button> <button class="btn-import" onclick="showEnhancedImportModal()">å¯¼å…¥</button> <button class="btn-reminder" onclick="showReminderModal()">æé†’</button> <button class="btn-reset" onclick="resetData()">é‡ç½®</button> <button class="btn-privacy" onclick="showPrivacyModal()">å£°æ˜</button> </div> <div class="search-container"> <div class="search-input-wrapper"> <input type="text" id="search-input" placeholder="æœç´¢æ‰€æœ‰å†…å®¹..." onkeypress="handleSearchKeypress(event)"> <button class="search-clear" id="search-clear" title="æ¸…é™¤æœç´¢">Ã—</button> </div> <button onclick="performSearch()">æœç´¢</button> <button class="calendar-button" onclick="showDateFilterModal()">ğŸ“…</button> </div> <div id="search-status" style="display: none; margin-bottom: 10px; padding: 8px; background: #e0f7fa; border-radius: 4px; font-size: 0.9rem;"> <span id="search-status-text"></span> <button onclick="clearSearch()" style="margin-left: 10px; padding: 2px 8px; background: #00796b; color: white; border: none; border-radius: 3px; cursor: pointer;">æ¸…é™¤æœç´¢</button> </div> </div> <div class="stats"> <div class="stat-item"> <div class="stat-value" id="achievement-count">0</div> <div>æˆå°±æ—¶åˆ»</div> <div class="streak-milestone"></div> </div> <div class="stat-item"> <div class="stat-value" id="skill-count">0</div> <div>èƒ½åŠ›å‘å±•</div> <div class="streak-milestone"></div> </div> <div class="stat-item"> <div class="stat-value" id="record-days">0</div> <div>è®°å½•å¤©æ•°</div> <div class="streak-milestone" id="record-milestone"></div> </div> </div> <div class="nav-tabs"> <div class="tab active" data-tab="achievements">æ¯æ—¥æˆå°±</div> <div class="tab" data-tab="skills">æŠ€èƒ½æˆé•¿</div> <div class="tab" data-tab="reflection">è‡ªæˆ‘å¯¹è¯</div> <div class="tab" data-tab="value">åˆ›é€ ä»·å€¼</div> </div> <div id="achievements" class="tab-content active"> <h2>æ¯æ—¥å¾®æˆå°±å’Œå°ç¡®å¹¸</h2> <p>åŸ¹å…»è‡ªæˆ‘è®¤å¯ï¼Œä»è®°å½•ä»Šå¤©å®Œæˆçš„3ä»¶å°äº‹å¼€å§‹ã€‚åŠæ—¶è®°å½•ç¾å¥½ï¼Œå¢åŠ ç”Ÿæ´»å¹¸ç¦æ„Ÿ~</p> <div class="input-group"> <input type="text" id="new-achievement" placeholder="ä»Šå¤©è®©æˆ‘æ„Ÿåˆ°å……å®ï¼Œå¹¸è¿æˆ–æœ‰æˆå°±æ„Ÿçš„äº‹æƒ…..."> <button onclick="addAchievement()">æ·»åŠ æˆå°±</button> </div> <div class="collapse-controls"> <button class="btn-collapse" onclick="toggleAllCollapsible('achievements')">å…¨éƒ¨æŠ˜å /å±•å¼€</button> </div> <div id="achievements-list"> </div> </div> <div id="skills" class="tab-content"> <h2>æŠ€èƒ½æˆé•¿åœ°å›¾</h2> <p>æ¯ä¸€æ¬¡ç»ƒä¹ éƒ½åœ¨ç»˜åˆ¶ä½ çš„èƒ½åŠ›ç‰ˆå›¾ã€‚æŒç»­è®°å½•ï¼Œæ¸…æ™°çœ‹åˆ°è‡ªå·±çš„è¿›æ­¥è½¨è¿¹</p> <div class="input-group"> <textarea id="new-skill" placeholder="ä½ æƒ³åŸ¹å…»ä»€ä¹ˆèƒ½åŠ›ï¼Ÿæˆ–è®°å½•å½“å‰çš„ç»ƒä¹ è¿›å±•" rows="1"></textarea> <button onclick="showSkillActionModal()">æ·»åŠ æŠ€èƒ½/æ‰“å¡</button> </div> <div class="skill-category-buttons"> <button class="skill-category-button active" data-category="all">å…¨éƒ¨</button> <button class="skill-category-button" data-category="want">æƒ³å­¦</button> <button class="skill-category-button" data-category="focus">è¿‘æœŸé‡ç‚¹</button> <button class="skill-category-button" data-category="completed">å·²å®Œæˆ</button> </div> <div class="collapse-controls"> <button class="btn-collapse" onclick="toggleAllCollapsible('skills')">å…¨éƒ¨æŠ˜å /å±•å¼€</button> </div> <div id="skills-list"> </div> </div> <div id="reflection" class="tab-content"> <h2>å†…åœ¨å¯¹è¯è§‰å¯Ÿ</h2> <p>å…³æ³¨ä½ å¯¹è‡ªå·±çš„è¯„ä»·æ–¹å¼ã€‚å®Œæˆä¸€ä»¶äº‹æ—¶ï¼Œè¯•ç€é—®ï¼š'è¿™æ¬¡ç»å†ä¸­ï¼Œæˆ‘æ¬£èµè‡ªå·±çš„å“ªäº›è¡¨ç°ï¼Ÿ''æˆ‘è·å¾—äº†ä»€ä¹ˆæ–°çš„ç†è§£ï¼Ÿ"</p><div class="input-group"> <textarea id="reflection-text" placeholder="ï¼ˆé»˜è®¤ç¬¬ä¸€è¡Œä¸ºæ ‡é¢˜ï¼‰&#10;æˆ‘åšå¾—å¥½çš„éƒ¨åˆ†æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»è¿™ä¸ªè¿‡ç¨‹å­¦åˆ°äº†ä»€ä¹ˆï¼Ÿ..." rows="4"></textarea></div><div class="reflection-buttons-container"> <button ondblclick="insertDiaryTemplate()" style="background-color: #ff9800;">æ—¥è®°æ¨¡æ¿</button> <button onclick="saveReflection()">ä¿å­˜åæ€</button></div> <div class="collapse-controls"> <button class="btn-collapse" onclick="toggleAllCollapsible('reflection')">å…¨éƒ¨æŠ˜å /å±•å¼€</button> </div> <div id="reflection-list"> </div> </div> <div id="value" class="tab-content"> <h2>åˆ›é€ ä»·å€¼è¾“å‡ºçš„å¾ªç¯</h2> <p>å½“ä½ å°†æ³¨æ„åŠ›ä»"è·å–åé¦ˆ"è½¬å‘"åˆ›é€ ä»·å€¼"æ—¶ï¼Œæ­£åé¦ˆä¼šè‡ªç„¶æ¶Œç°</p> <div class="value-category-buttons"> <button class="value-category-button active" data-category="share">çŸ¥è¯†åˆ†äº«</button> <button class="value-category-button" data-category="project">å®Œæˆå°é¡¹ç›®</button> <button class="value-category-button" data-category="help">æä¾›æ— å¿å¸®åŠ©</button> <button class="value-category-button" data-category="partnership">å¤–éƒ¨æ”¯æŒä¸åé¦ˆ</button> </div> <div id="value-input-share" class="value-input-area active"> <h3>çŸ¥è¯†åˆ†äº«</h3> <p>åœ¨ç¤¾äº¤åª’ä½“æˆ–ä¸ªäººç½‘ç«™ä¸Šåˆ†äº«ä½ çš„ä¸“ä¸šçŸ¥è¯†æˆ–å­¦ä¹ å¿ƒå¾—ï¼Œæ—¢èƒ½å·©å›ºå­¦ä¹ æˆæœåˆèƒ½ä¼ æ’­ä¸äº¤æµ</p> <div class="input-group"> <textarea id="new-share" placeholder="æˆ‘ä»Šå¤©åˆ†äº«äº†..." rows="3"></textarea> <button onclick="addValueOutput('share')">è®°å½•åˆ†äº«</button> </div> </div> <div id="value-input-project" class="value-input-area"> <h3>å®Œæˆå°é¡¹ç›®</h3> <p>è®¾å®šä¸€äº›èƒ½å¤ŸçŸ­æœŸå†…å®Œæˆå¹¶æœ‰æ˜ç¡®äº§å‡ºçš„å°é¡¹ç›®ï¼Œä½“éªŒå®Œæ•´çš„æˆå°±å¾ªç¯</p> <div class="input-group"> <textarea id="new-project" placeholder="æˆ‘å®Œæˆçš„é¡¹ç›®æ˜¯..." rows="3"></textarea> <button onclick="addValueOutput('project')">è®°å½•é¡¹ç›®</button> </div> </div> <div id="value-input-help" class="value-input-area"> <h3>æä¾›æ— å¿å¸®åŠ©</h3> <p>åœ¨ä½ èƒ½èƒœä»»çš„é¢†åŸŸä¸»åŠ¨å¸®åŠ©ä»–äººï¼Œè¿‡ç¨‹ä¸­è·å¾—çš„æ„Ÿè°¢ä¸è®¤å¯æ˜¯æœ€çœŸå®çš„</p> <div class="input-group"> <textarea id="new-help" placeholder="æˆ‘å¸®åŠ©äº†..." rows="3"></textarea> <button onclick="addValueOutput('help')">è®°å½•å¸®åŠ©</button> </div> </div> <div id="value-input-partnership" class="value-input-area"> <h3>å¤–éƒ¨æ”¯æŒä¸åé¦ˆ</h3> <p>è®°å½•ä»»ä½•ä¸ºä½ å¸¦æ¥æˆé•¿åŠ¨åŠ›çš„å¤–éƒ¨æ”¯æŒ - æ— è®ºæ˜¯åŠ å…¥ç¤¾ç¾¤ã€å»ºç«‹ä¼™ä¼´å…³ç³»ï¼Œè¿˜æ˜¯è·å¾—ä»–äººçš„è®¤å¯å’Œé¼“åŠ±</p> <div class="input-group"> <textarea id="new-partnership" placeholder="ä¾‹å¦‚ï¼šåŠ å…¥äº†XXå­¦ä¹ ç¤¾ç¾¤ï¼Œä¸æœ‹å‹å®šæœŸäº¤æµè¿›å±•ï¼Œæ”¶åˆ°äº†åŒäº‹çš„ç§¯æåé¦ˆï¼Œåœ¨è®ºå›ä¸Šè·å¾—äº†è®¤å¯..." rows="3"></textarea> <button onclick="addValueOutput('partnership')">è®°å½•æ”¯æŒ</button> </div> </div> <div class="collapse-controls"> <button class="btn-collapse" onclick="toggleAllCollapsible('value')">å…¨éƒ¨æŠ˜å /å±•å¼€</button> </div> <div id="value-outputs-list"> </div> </div> </div> <div id="checkin-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3 id="checkin-skill-name">æŠ€èƒ½æ‰“å¡</h3> <button class="modal-close" onclick="closeModal('checkin-modal')">&times;</button> </div> <p>è®°å½•ä½ ä»Šå¤©çš„è¿›æ­¥æˆ–æˆæœï¼š</p> <textarea id="checkin-content" rows="4" placeholder="æˆ‘ä»Šå¤©åœ¨è¿™ä¸ªæŠ€èƒ½ä¸Šå–å¾—äº†ä»€ä¹ˆè¿›æ­¥..."></textarea> <div class="action-buttons"> <button onclick="closeModal('checkin-modal')">å–æ¶ˆ</button> <button onclick="submitCheckin()">æäº¤æ‰“å¡</button> </div> </div> </div> <div id="skill-action-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>æ·»åŠ æŠ€èƒ½/æ‰“å¡</h3> <button class="modal-close" onclick="closeModal('skill-action-modal')">&times;</button> </div> <p>é€‰æ‹©è¦æ“ä½œçš„æŠ€èƒ½ï¼š</p> <select id="skill-action-select" style="width: 100%; margin: 10px 0;"> <option value="new">æ–°æŠ€èƒ½</option> </select> <div class="action-buttons"> <button onclick="closeModal('skill-action-modal')">å–æ¶ˆ</button> <button onclick="processSkillAction()">ç¡®å®š</button> </div> </div> </div> <div id="edit-achievement-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>ä¿®æ”¹æˆå°±</h3> <button class="modal-close" onclick="closeModal('edit-achievement-modal')">&times;</button> </div> <p>ä¿®æ”¹æˆå°±å†…å®¹ï¼š</p> <textarea id="edit-achievement-content" rows="4" placeholder="è¯·è¾“å…¥æ–°çš„æˆå°±å†…å®¹..."></textarea> <div class="action-buttons"> <button onclick="closeEditModal('achievement')">å–æ¶ˆ</button> <button onclick="saveEditModal()">ä¿å­˜ä¿®æ”¹</button> </div> </div> </div> <div id="edit-reflection-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>ä¿®æ”¹åæ€</h3> <button class="modal-close" onclick="closeModal('edit-reflection-modal')">&times;</button> </div> <p>ä¿®æ”¹åæ€å†…å®¹ï¼š</p> <textarea id="edit-reflection-content" rows="4" placeholder="è¯·è¾“å…¥æ–°çš„åæ€å†…å®¹..."></textarea> <div class="action-buttons"> <button onclick="closeEditModal('reflection')">å–æ¶ˆ</button> <button onclick="saveEditModal()">ä¿å­˜ä¿®æ”¹</button> </div> </div> </div> <div id="edit-checkin-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>ä¿®æ”¹æ‰“å¡è®°å½•</h3> <button class="modal-close" onclick="closeModal('edit-checkin-modal')">&times;</button> </div> <p>ä¿®æ”¹æ‰“å¡å†…å®¹ï¼š</p> <textarea id="edit-checkin-content" rows="4" placeholder="è¯·è¾“å…¥æ–°çš„æ‰“å¡å†…å®¹..."></textarea> <div class="action-buttons"> <button onclick="closeEditModal('checkin')">å–æ¶ˆ</button> <button onclick="saveEditModal()">ä¿å­˜ä¿®æ”¹</button> </div> </div> </div> <div id="edit-skill-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>ä¿®æ”¹æŠ€èƒ½åç§°</h3> <button class="modal-close" onclick="closeModal('edit-skill-modal')">&times;</button> </div> <p>ä¿®æ”¹æŠ€èƒ½åç§°ï¼š</p> <input type="text" id="edit-skill-name" placeholder="è¯·è¾“å…¥æ–°çš„æŠ€èƒ½åç§°..."> <div class="action-buttons"> <button onclick="closeEditModal('skill')">å–æ¶ˆ</button> <button onclick="saveEditModal()">ä¿å­˜ä¿®æ”¹</button> </div> </div> </div> <div id="edit-value-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>ä¿®æ”¹ä»·å€¼è¾“å‡º</h3> <button class="modal-close" onclick="closeModal('edit-value-modal')">&times;</button> </div> <p>ä¿®æ”¹ä»·å€¼è¾“å‡ºå†…å®¹ï¼š</p> <textarea id="edit-value-content" rows="4" placeholder="è¯·è¾“å…¥æ–°çš„å†…å®¹..."></textarea> <div class="action-buttons"> <button onclick="closeEditModal('value')">å–æ¶ˆ</button> <button onclick="saveEditModal()">ä¿å­˜ä¿®æ”¹</button> </div> </div> </div> <div id="enhanced-export-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>å¯¼å‡ºæ•°æ® - é«˜çº§é€‰é¡¹</h3> <button class="modal-close" onclick="closeModal('enhanced-export-modal')">&times;</button> </div> <div class="export-options"> <h4>æ—¥æœŸèŒƒå›´</h4> <div class="date-range-inputs"> <input type="date" id="export-start-date"> <span>è‡³</span> <input type="date" id="export-end-date"> </div> <h4>é€‰æ‹©åˆ†ç±»</h4> <div class="export-categories"> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1px;"> <label class="export-category-label" style="display: flex; align-items: center; gap: 2px; padding: 2px 0;"> <span style="font-size: 0.85rem;">æ¯æ—¥æˆå°±</span><input type="checkbox" id="export-achievements" class="export-category-checkbox" checked style="margin: 0;"> </label> <label class="export-category-label" style="display: flex; align-items: center; gap: 2px; padding: 2px 0;"> <span style="font-size: 0.85rem;">æŠ€èƒ½æˆé•¿</span><input type="checkbox" id="export-skills" class="export-category-checkbox" checked style="margin: 0;"> </label> <label class="export-category-label" style="display: flex; align-items: center; gap: 2px; padding: 2px 0;"> <span style="font-size: 0.85rem;">è‡ªæˆ‘å¯¹è¯</span><input type="checkbox" id="export-reflections" class="export-category-checkbox" checked style="margin: 0;"> </label> <label class="export-category-label" style="display: flex; align-items: center; gap: 2px; padding: 2px 0;"> <span style="font-size: 0.85rem;">åˆ›é€ ä»·å€¼</span><input type="checkbox" id="export-value" class="export-category-checkbox" checked style="margin: 0;"> </label> </div> </div> <div class="export-preview"> <h4>æ•°æ®é¢„è§ˆ</h4> <div style="margin-bottom: 10px; display: flex; gap: 5px;"> <button id="preview-json-btn" class="preview-format-btn active" onclick="switchPreviewFormat('json')">æºæ•°æ®</button> <button id="preview-md-btn" class="preview-format-btn" onclick="switchPreviewFormat('md')">MDæ ¼å¼</button> </div> <textarea id="enhanced-export-data" rows="5" readonly></textarea> <div style="margin-top: 10px;"> <h4>å¯¼å‡ºæ–‡ä»¶å</h4> <div style="display: flex; gap: 5px; align-items: center;"> <input type="text" id="export-filename-display" readonly style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9;"> <button onclick="copyExportFilename()" style="padding: 8px 12px; white-space: nowrap;">å¤åˆ¶æ–‡ä»¶å</button> </div> </div> </div> </div> <div class="action-buttons"> <button onclick="closeModal('enhanced-export-modal')">å–æ¶ˆ</button> <button onclick="downloadEnhancedData()">ä¸‹è½½æ–‡ä»¶</button> </div> </div> </div> <div id="enhanced-import-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>å¯¼å…¥æ•°æ® - è¯¦ç»†é¢„è§ˆ</h3> <button class="modal-close" onclick="closeModal('enhanced-import-modal')">&times;</button> </div> <p>é€‰æ‹©è¦å¯¼å…¥çš„JSONæ–‡ä»¶ï¼š</p> <input type="file" id="import-files" accept=".json" style="margin: 15px 0;"> <div id="import-preview" style="display: none; margin: 15px 0;"> <h4>å¯¼å…¥é¢„è§ˆ - è¯·é€‰æ‹©è¦å¯¼å…¥çš„åˆ†ç±»</h4> <div class="import-categories" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; padding: 10px;"> <div class="import-category-section" style="margin-bottom: 15px;"> <div style="display: flex; align-items: center; justify-content: space-between;"> <strong>æ¯æ—¥æˆå°± (å…± <span id="import-achievements-count">0</span> æ¡)</strong> <label class="export-category-label" style="display: flex; align-items: center; gap: 8px;"> <span style="font-size: 0.85rem;">å…¨é€‰</span> <input type="checkbox" id="import-all-achievements" class="import-category-checkbox" checked> </label> </div> <div id="import-achievements-details" style="margin-left: 10px; font-size: 0.9rem; color: #666;"> </div> </div> <div class="import-category-section"> <label style="display: flex; align-items: center; justify-content: space-between;"> <strong>æŠ€èƒ½æˆé•¿ (å…± <span id="import-skills-count">0</span> é¡¹)</strong> <label class="export-category-label" style="display: flex; align-items: center; gap: 8px;"> <span style="font-size: 0.85rem;">å…¨é€‰</span> <input type="checkbox" id="import-all-skills" class="import-category-checkbox" checked> </label> </div> <div id="import-skills-details" style="margin-left: 10px; font-size: 0.9rem; color: #666;"> </div> <div class="import-category-section"> <label style="display: flex; align-items: center; justify-content: space-between;"> <strong>è‡ªæˆ‘å¯¹è¯ (å…± <span id="import-reflections-count">0</span> æ¡)</strong> <label class="export-category-label" style="display: flex; align-items: center; gap: 8px;"> <span style="font-size: 0.85rem;">å…¨é€‰</span> <input type="checkbox" id="import-all-reflections" class="import-category-checkbox" checked> </label> </div> <div id="import-reflections-details" style="margin-left: 10px; font-size: 0.9rem; color: #666;"> </div> <div class="import-category-section" style="margin-bottom: 15px;"> <div style="display: flex; align-items: center; justify-content: space-between;"> <strong>åˆ›é€ ä»·å€¼ (å…± <span id="import-value-count">0</span> æ¡)</strong> <label class="export-category-label" style="display: flex; align-items: center; gap: 8px;"> <span style="font-size: 0.85rem;">å…¨é€‰</span> <input type="checkbox" id="import-all-value" class="import-category-checkbox" checked> </label> </div> <div id="import-value-details" style="margin-left: 10px; font-size: 0.9rem; color: #666;"> </div> </div> </div> <div id="import-summary" style="margin-top: 15px; padding: 10px; background: #f5f5f5; border-radius: 5px;"> <strong>å¯¼å…¥ç»Ÿè®¡ï¼š</strong> <span id="import-total-count">0</span> æ¡è®°å½•ï¼Œé¢„è®¡å ç”¨ <span id="import-total-size">0</span> KB </div> </div> <div id="import-progress" style="display: none;"> <div class="progress-bar"> <div class="progress" id="import-progress-bar" style="width: 0%"></div> </div> <p id="import-progress-text">å¤„ç†ä¸­...</p> </div> <div id="import-results" style="max-height: 200px; overflow-y: auto; margin: 10px 0;"></div> <div class="action-buttons"> <button onclick="closeModal('enhanced-import-modal')">å–æ¶ˆ</button> <button id="start-import-btn" onclick="importMultipleData()" disabled>å¼€å§‹å¯¼å…¥</button> </div> </div> </div> <div id="reset-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>é€‰æ‹©æ€§é‡ç½®æ•°æ®</h3> <button class="modal-close" onclick="closeModal('reset-modal')">&times;</button> </div> <p>è¯·é€‰æ‹©è¦é‡ç½®çš„æ•°æ®åˆ†ç±»å’Œæ—¥æœŸèŒƒå›´ï¼š</p> <div class="reset-categories" style="margin: 15px 0;"> <h4>é€‰æ‹©åˆ†ç±»</h4> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;"> <label style="display: flex; align-items: center; justify-content: space-between;"> <span>æ¯æ—¥æˆå°±</span> <input type="checkbox" id="reset-achievements" class="reset-category-checkbox"> </label> <label style="display: flex; align-items: center; justify-content: space-between;"> <span>æŠ€èƒ½æˆé•¿</span> <input type="checkbox" id="reset-skills" class="reset-category-checkbox"> </label> <label style="display: flex; align-items: center; justify-content: space-between;"> <span>è‡ªæˆ‘å¯¹è¯</span> <input type="checkbox" id="reset-reflections" class="reset-category-checkbox"> </label> <label style="display: flex; align-items: center; justify-content: space-between;"> <span>åˆ›é€ ä»·å€¼</span> <input type="checkbox" id="reset-value" class="reset-category-checkbox"> </label> </div> </div> <div class="reset-date-range" style="margin: 15px 0;"> <h4>æ—¥æœŸèŒƒå›´ï¼ˆå¯é€‰ï¼‰</h4> <label style="display: flex; align-items: center; justify-content: space-between; margin-top: 8px;"> <span>é‡ç½®æ‰€æœ‰æ—¥æœŸ</span> <input type="checkbox" id="reset-all-dates"> </label> <div class="date-range-inputs"> <input type="date" id="reset-start-date"> <span>è‡³</span> <input type="date" id="reset-end-date"> </div> </div> <div id="reset-summary" style="margin: 15px 0; padding: 15px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px;"> <h4>é‡ç½®æ‘˜è¦</h4> <div id="reset-details"> <p>è¯·é€‰æ‹©è¦é‡ç½®çš„åˆ†ç±»...</p> </div> <div style="margin-top: 10px; font-weight: bold;"> æ€»è®¡: <span id="reset-total-count">0</span> æ¡è®°å½•ï¼Œé‡Šæ”¾çº¦ <span id="reset-total-size">0</span> KB ç©ºé—´ </div> </div> <div style="margin: 15px 0;"> <p>è¯·è¾“å…¥å¯†ç ç¡®è®¤é‡ç½®ï¼š</p> <input type="password" id="reset-password" class="password-input" placeholder="è¯·è¾“å…¥å¯†ç "> <div id="password-error" class="password-error">å¯†ç é”™è¯¯ï¼Œè¯·é‡æ–°è¾“å…¥</div> </div> <div class="action-buttons"> <button onclick="closeModal('reset-modal')">å–æ¶ˆ</button> <button class="btn-danger" onclick="confirmResetData()" id="confirm-reset-btn" disabled>ç¡®è®¤é‡ç½®</button> </div> </div> </div> <div id="reminder-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>æ•°æ®å¤‡ä»½æé†’è®¾ç½®</h3> <button class="modal-close" onclick="closeModal('reminder-modal')">&times;</button> </div> <div class="reminder-options"> <h4>æé†’è®¾ç½®</h4> <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 15px;"> <label for="enable-reminder" style="margin: 0;">æ˜¯å¦å¯ç”¨æ•°æ®å¤‡ä»½æé†’â†’</label> <input type="checkbox" id="enable-reminder" onchange="toggleReminderDetails()"> </div> <div id="reminder-details" style="display: none; margin-top: 15px;"> <div class="reminder-type"> <label> <input type="radio" name="reminder-type" value="weekly" checked onchange="toggleReminderType()"> æ¯å‘¨æé†’ </label> <label> <input type="radio" name="reminder-type" value="monthly" onchange="toggleReminderType()"> æ¯æœˆæé†’ </label> </div> <div id="weekly-reminder" class="reminder-details"> <label>é€‰æ‹©æ˜ŸæœŸå‡ æé†’ï¼š</label> <select id="reminder-weekday"> <option value="0">æ˜ŸæœŸæ—¥</option> <option value="1">æ˜ŸæœŸä¸€</option> <option value="2">æ˜ŸæœŸäºŒ</option> <option value="3">æ˜ŸæœŸä¸‰</option> <option value="4">æ˜ŸæœŸå››</option> <option value="5">æ˜ŸæœŸäº”</option> <option value="6">æ˜ŸæœŸå…­</option> </select> </div> <div id="monthly-reminder" class="reminder-details" style="display: none;"> <label>é€‰æ‹©æ¯æœˆå‡ å·æé†’ï¼š</label> <select id="reminder-day"> </select> </div> </div> </div> <div class="action-buttons"> <button onclick="closeModal('reminder-modal')">å–æ¶ˆ</button> <button onclick="saveReminderSettings()">ä¿å­˜è®¾ç½®</button> </div> </div> </div> <div id="date-filter-modal" class="modal"> <div class="modal-content"> <div class="modal-header"> <h3>æŒ‰æ—¥æœŸç­›é€‰</h3> <button class="modal-close" onclick="closeModal('date-filter-modal')">&times;</button> </div> <div class="date-filter-tabs"> <div class="date-filter-tab active" data-filter-type="day">æŒ‰æ—¥æœŸ</div> <div class="date-filter-tab" data-filter-type="month">æŒ‰æœˆä»½</div> <div class="date-filter-tab" data-filter-type="year">æŒ‰å¹´ä»½</div> <div class="date-filter-tab" data-filter-type="range">æ—¥æœŸèŒƒå›´</div> </div> <div id="date-filter-day" class="date-filter-content active"> <p>é€‰æ‹©è¦ç­›é€‰çš„æ—¥æœŸï¼š</p> <input type="date" id="date-filter-input" style="width: 100%; margin: 10px 0;"> <div class="action-buttons"> <button onclick="closeModal('date-filter-modal')">å–æ¶ˆ</button> <button onclick="applyDateFilter('day')">åº”ç”¨ç­›é€‰</button> <button onclick="clearDateFilter()">æ¸…é™¤ç­›é€‰</button> </div> </div> <div id="date-filter-month" class="date-filter-content"> <p>é€‰æ‹©è¦ç­›é€‰çš„æœˆä»½ï¼š</p> <input type="month" id="month-filter-input" style="width: 100%; margin: 10px 0;"> <div class="action-buttons"> <button onclick="closeModal('date-filter-modal')">å–æ¶ˆ</button> <button onclick="applyDateFilter('month')">åº”ç”¨ç­›é€‰</button> <button onclick="clearDateFilter()">æ¸…é™¤ç­›é€‰</button> </div> </div> <div id="date-filter-year" class="date-filter-content"> <p>é€‰æ‹©è¦ç­›é€‰çš„å¹´ä»½ï¼š</p> <input type="number" id="year-filter-input" min="2000" max="2030" value="2023" style="width: 100%; margin: 10px 0;"> <div class="action-buttons"> <button onclick="closeModal('date-filter-modal')">å–æ¶ˆ</button> <button onclick="applyDateFilter('year')">åº”ç”¨ç­›é€‰</button> <button onclick="clearDateFilter()">æ¸…é™¤ç­›é€‰</button> </div> </div> <div id="date-filter-range" class="date-filter-content"> <p>é€‰æ‹©æ—¥æœŸèŒƒå›´ï¼š</p> <div class="date-range-inputs"> <input type="date" id="start-date-input" placeholder="å¼€å§‹æ—¥æœŸ"> <input type="date" id="end-date-input" placeholder="ç»“æŸæ—¥æœŸ"> </div> <div class="action-buttons"> <button onclick="closeModal('date-filter-modal')">å–æ¶ˆ</button> <button onclick="applyDateFilter('range')">åº”ç”¨ç­›é€‰</button> <button onclick="clearDateFilter()">æ¸…é™¤ç­›é€‰</button> </div> </div> <div class="calendar-container" id="calendar-container"> </div> </div> </div> <script> let currentExportFormat = 'json'; let appData = { achievements: [], skills: [], reflections: [], valueOutputs: [], recordData: { recordDays: 0, recordDates: [] }, reminderSettings: { enabled: true, type: 'weekly', day: 6, lastReminded: null } };let currentSkillId; let currentEditItem = { type: null, id: null, skillId: null };function showPrivacyModal() { document.getElementById('privacy-modal').style.display = 'flex';}function openEditModal(type, id, skillId = null) { const handler = editHandlers[type]; if (!handler) { console.error('æœªçŸ¥çš„ç¼–è¾‘ç±»å‹:', type); return; } let item; if (type === 'checkin') { item = handler.findItem(id, skillId); } else { const dataMap = { 'achievement': 'achievements', 'reflection': 'reflections', 'skill': 'skills', 'value': 'valueOutputs' }; item = appData[dataMap[type]].find(item => item.id === id); } if (!item) { alert('æœªæ‰¾åˆ°è¦ç¼–è¾‘çš„æ¡ç›®'); return; } currentEditItem = { type, id, skillId }; const elements = handler.getModalElements(); const contentElement = document.getElementById(elements.content); if (contentElement) { contentElement.value = handler.getContent(item); document.getElementById(elements.modal).style.display = 'flex'; }}function saveEditModal() { const { type, id, skillId } = currentEditItem; const handler = editHandlers[type]; if (!type || !id || !handler) { alert('ç¼–è¾‘çŠ¶æ€å¼‚å¸¸'); return; } const elements = handler.getModalElements(); const contentElement = document.getElementById(elements.content); const content = validateInput(contentElement.value, 'å†…å®¹'); if (content === null) return; if (!content) { alert('è¯·è¾“å…¥å†…å®¹'); return; } let item; if (type === 'checkin') { const skill = appData.skills.find(s => s.id === skillId); item = skill ? skill.checkins.find(c => c.id === id) : null; } else { const dataMap = { 'achievement': 'achievements', 'reflection': 'reflections', 'skill': 'skills', 'value': 'valueOutputs' }; item = appData[dataMap[type]].find(item => item.id === id); } if (!item) { alert('æœªæ‰¾åˆ°è¦ç¼–è¾‘çš„æ¡ç›®'); return; } let success = true; if (type === 'skill') { success = handler.setContent(item, content); if (!success) return; } else { handler.setContent(item, content); } if (type !== 'skill') {const datetime = getCurrentDateTime();const modificationRecord = { date: datetime.date, time: datetime.time}; if (!item.modificationHistory) { item.modificationHistory = []; } item.modificationHistory.push(modificationRecord); if (item.modificationHistory.length > 3) { item.modificationHistory = item.modificationHistory.slice(-3); } } saveData(); handler.render(); closeEditModal(type);}function closeEditModal(type) { const handler = editHandlers[type]; if (!handler) { console.error('æœªçŸ¥çš„ç¼–è¾‘ç±»å‹:', type); return; } const elements = handler.getModalElements(); document.getElementById(elements.modal).style.display = 'none'; currentEditItem = { type: null, id: null, skillId: null };}const editHandlers = { achievement: { getContent: (item) => item.text, setContent: (item, content) => { item.text = content; }, getModalElements: () => ({ modal: 'edit-achievement-modal', content: 'edit-achievement-content' }), render: renderAchievements }, reflection: { getContent: (item) => item.text, setContent: (item, content) => { item.text = content; }, getModalElements: () => ({ modal: 'edit-reflection-modal', content: 'edit-reflection-content' }), render: renderReflections }, checkin: { getContent: (item) => item.content, setContent: (item, content) => { item.content = content; }, getModalElements: () => ({ modal: 'edit-checkin-modal', content: 'edit-checkin-content' }), render: renderSkills, findItem: (id, skillId) => { const skill = appData.skills.find(s => s.id === skillId); return skill ? skill.checkins.find(c => c.id === id) : null; } }, skill: { getContent: (item) => item.name, setContent: (item, content) => { if (appData.skills.some(s => s.id !== item.id && s.name === content)) { alert('å·²å­˜åœ¨åŒåæŠ€èƒ½'); return false; } item.name = content; return true; }, getModalElements: () => ({ modal: 'edit-skill-modal', content: 'edit-skill-name' }), render: renderSkills }, value: { getContent: (item) => item.text, setContent: (item, content) => { item.text = content; }, getModalElements: () => ({ modal: 'edit-value-modal', content: 'edit-value-content' }), render: renderValueOutputs }};function showModal(modalId) { document.getElementById(modalId).style.display = 'flex';}function closeModal(modalId) { document.getElementById(modalId).style.display = 'none';}function getCurrentDateTime() { const now = new Date(); return { date: now.toLocaleDateString(), time: now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}), timestamp: now.getTime() };}function generateId() { return Date.now() + Math.floor(Math.random() * 1000);} let collapseState = { achievements: {}, skills: {}, reflection: {}, value: {} }; let searchKeyword = ''; let dateFilter = ''; let skillCategoryFilter = 'all'; function loadData() { const saved = localStorage.getItem('feedbackAssistantData'); if (saved) { try { appData = JSON.parse(saved); migrateData(); } catch (e) { console.error("è§£æä¿å­˜çš„æ•°æ®æ—¶å‡ºé”™:", e); } } updateStats(); renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); checkRecordDays(); initSearchClearButton(); initHeaderControls(); checkReminder(); function restoreInputs() { const inputsToSave = [ 'new-achievement', 'new-skill', 'reflection-text', 'new-share', 'new-project', 'new-help', 'new-partnership' ]; inputsToSave.forEach(id => { const input = document.getElementById(id); if (input) { const savedValue = localStorage.getItem(`input_${id}`); if (savedValue) { input.value = savedValue; } input.addEventListener('input', function() { localStorage.setItem(`input_${id}`, this.value); }); } }); } restoreInputs(); } function checkReminder() { const settings = appData.reminderSettings; if (!settings.enabled) return; const datetime = getCurrentDateTime();const today = new Date(datetime.timestamp);const todayDate = today.getDate();const todayDay = today.getDay(); let shouldRemind = false; if (settings.type === 'weekly') { if (todayDay === settings.day) { shouldRemind = true; } } else if (settings.type === 'monthly') { if (todayDate === settings.day) { shouldRemind = true; } } if (shouldRemind) { const lastReminded = settings.lastReminded ? new Date(settings.lastReminded) : null; const todayString = today.toDateString(); if (!lastReminded || lastReminded.toDateString() !== todayString) { showReminder(); } } } function showReminder() { const header = document.getElementById('main-header'); header.classList.add('reminder'); header.querySelector('h1').textContent = 'è®°å¾—å¯¼å‡ºå’Œå¤‡ä»½æ•°æ®'; header.querySelector('p').textContent = 'ç‚¹å‡»æ­¤å¤„æ¢å¤'; header.onclick = function() { hideReminder(); toggleHeaderControls(); }; } function hideReminder() { const header = document.getElementById('main-header'); header.classList.remove('reminder'); header.querySelector('h1').textContent = 'æ­£åé¦ˆæˆé•¿åŠ©æ‰‹'; header.querySelector('p').textContent = 'è®°å½•æˆé•¿ï¼Œå‘ç°æ›´å¥½çš„è‡ªå·±'; header.onclick = function() { toggleHeaderControls(); }; appData.reminderSettings.lastReminded = new Date().toISOString(); saveData(); } function toggleHeaderControls() { const headerControls = document.querySelector('.header-controls'); headerControls.classList.toggle('visible'); } function initHeaderControls() { const headerControls = document.querySelector('.header-controls'); headerControls.classList.remove('visible'); } function updateSearchStatus() { const statusElement = document.getElementById('search-status'); const statusTextElement = document.getElementById('search-status-text'); if (searchKeyword) { let totalMatches = 0; appData.achievements.forEach(achievement => { if (isItemVisible(achievement, achievement.date)) { totalMatches++; } }); const countedSkills = new Set(); appData.skills.forEach(skill => { if (isSkillVisible(skill)) { if (!countedSkills.has(skill.id)) { countedSkills.add(skill.id); totalMatches++; } skill.checkins.forEach(checkin => { if (isItemVisible(checkin, checkin.date)) { totalMatches++; } }); } }); appData.reflections.forEach(reflection => { if (isItemVisible(reflection, reflection.date)) { totalMatches++; } }); appData.valueOutputs.forEach(valueOutput => { if (isItemVisible(valueOutput, valueOutput.date)) { totalMatches++; } }); statusTextElement.textContent = `æœç´¢å…³é”®è¯: "${searchKeyword}"ï¼Œæ‰¾åˆ° ${totalMatches} ä¸ªåŒ¹é…ç»“æœ`; statusElement.style.display = 'block'; } else { statusElement.style.display = 'none'; } } function handleSearchKeypress(event) { if (event.key === 'Enter') { performSearch(); } } function initSearchClearButton() { const searchInput = document.getElementById('search-input'); const clearButton = document.getElementById('search-clear'); clearButton.addEventListener('click', function() { searchInput.value = ''; clearSearch(); }); } function clearSearch() { searchKeyword = ''; document.getElementById('search-input').value = ''; dateFilter = ''; renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); document.getElementById('search-status').style.display = 'none'; } function fixMissingTimestamp(dateStr, timeStr) { try { let date = new Date(dateStr); if (isNaN(date.getTime())) { console.warn('æ— æ•ˆæ—¥æœŸæ ¼å¼ï¼Œä½¿ç”¨å½“å‰æ—¥æœŸ:', dateStr); date = new Date(); } if (timeStr && timeStr !== "æœªçŸ¥æ—¶é—´") { const timeMatch = timeStr.match(/(\d+):(\d+)(?:\s*(AM|PM))?/i); if (timeMatch) { let hours = parseInt(timeMatch[1]); const minutes = parseInt(timeMatch[2]); const period = timeMatch[3]; if (period) { if (period.toUpperCase() === 'PM' && hours < 12) { hours += 12; } else if (period.toUpperCase() === 'AM' && hours === 12) { hours = 0; } } if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) { date.setHours(hours, minutes, 0, 0); } } } return date.getTime(); } catch (e) { console.error('ä¿®å¤æ—¶é—´æˆ³å¤±è´¥ï¼Œä½¿ç”¨å½“å‰æ—¶é—´:', e); return new Date().getTime(); } }function filterByDateRange(records, startDate, endDate) { if (!startDate || !endDate) return records; const start = new Date(startDate); const end = new Date(endDate); end.setHours(23, 59, 59, 999); return records.filter(record => { const recordDate = new Date(record.date); return recordDate >= start && recordDate <= end; });} function validateInput(text, fieldName) { const trimmed = text.trim(); if (!trimmed) { alert(`è¯·è¾“å…¥${fieldName}`); return null; } return trimmed;} function migrateData() { appData.achievements.forEach(achievement => { if (!achievement.time) { achievement.time = "æœªçŸ¥æ—¶é—´"; } if (!achievement.timestamp) { achievement.timestamp = fixMissingTimestamp(achievement.date, achievement.time); } else if (achievement.timestamp instanceof Date) { achievement.timestamp = achievement.timestamp.getTime(); } }); appData.reflections.forEach(reflection => { if (!reflection.time) { reflection.time = "æœªçŸ¥æ—¶é—´"; } if (!reflection.timestamp) { reflection.timestamp = fixMissingTimestamp(reflection.date, reflection.time); } else if (reflection.timestamp instanceof Date) { reflection.timestamp = reflection.timestamp.getTime(); } }); appData.valueOutputs.forEach(valueOutput => { if (!valueOutput.time) { valueOutput.time = "æœªçŸ¥æ—¶é—´"; } if (!valueOutput.timestamp) { valueOutput.timestamp = fixMissingTimestamp(valueOutput.date, valueOutput.time); } else if (valueOutput.timestamp instanceof Date) { valueOutput.timestamp = valueOutput.timestamp.getTime(); } }); appData.skills.forEach(skill => { if (!skill.category) { skill.category = 'want'; } if (!skill.progressType) { skill.progressType = 'days'; } skill.checkins.forEach(checkin => { if (!checkin.time) { checkin.time = "æœªçŸ¥æ—¶é—´"; } if (!checkin.timestamp) { checkin.timestamp = fixMissingTimestamp(checkin.date, checkin.time); } else if (checkin.timestamp instanceof Date) { checkin.timestamp = checkin.timestamp.getTime(); } }); }); if (!appData.recordData) { appData.recordData = { recordDays: appData.streakData ? appData.streakData.recordDates.length : 0, recordDates: appData.streakData ? appData.streakData.recordDates : [] }; delete appData.streakData; } if (!appData.reminderSettings) { appData.reminderSettings = { enabled: false, type: 'weekly', day: 5, lastReminded: null }; } saveData(); } function safeTextInput(text) { if (typeof text !== 'string') return text; return text .replace(/&/g, '&amp;') .replace(/</g, '&lt;') .replace(/>/g, '&gt;') .replace(/"/g, '&quot;') .replace(/'/g, '&#x27;') .replace(/\n/g, '<br>'); } function restoreTextDisplay(text) { if (typeof text !== 'string') return text; return text .replace(/&amp;/g, '&') .replace(/&lt;/g, '<') .replace(/&gt;/g, '>') .replace(/&quot;/g, '"') .replace(/&#x27;/g, "'") .replace(/<br>/g, '\n'); } function saveData() { localStorage.setItem('feedbackAssistantData', JSON.stringify(appData)); } function updateStats() { document.getElementById('achievement-count').textContent = appData.achievements.length; document.getElementById('skill-count').textContent = appData.skills.length; document.getElementById('record-days').textContent = appData.recordData.recordDays; const milestoneElement = document.getElementById('record-milestone'); const recordDays = appData.recordData.recordDays; if (recordDays >= 7 && recordDays < 30) { milestoneElement.textContent = "ä¸€å‘¨è®°å½•ï¼"; } else if (recordDays >= 30 && recordDays < 100) { milestoneElement.textContent = "ä¸€æœˆè®°å½•ï¼"; } else if (recordDays >= 100) { milestoneElement.textContent = "ç™¾æ—¥è®°å½•ï¼"; } else { milestoneElement.textContent = ""; } } function checkRecordDays() { const recordDates = getAllRecordDates(); appData.recordData.recordDays = recordDates.length; appData.recordData.recordDates = recordDates; saveData(); } function getAllRecordDates() { const dates = new Set(); appData.achievements.forEach(achievement => { dates.add(achievement.date); }); appData.skills.forEach(skill => { skill.checkins.forEach(checkin => { dates.add(checkin.date); }); }); appData.reflections.forEach(reflection => { dates.add(reflection.date); }); appData.valueOutputs.forEach(valueOutput => { dates.add(valueOutput.date); }); return Array.from(dates); } document.querySelectorAll('.tab').forEach(tab => { tab.addEventListener('click', () => { document.querySelectorAll('.tab').forEach(t => t.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active')); tab.classList.add('active'); document.getElementById(tab.dataset.tab).classList.add('active'); }); });function addAchievement() { const input = document.getElementById('new-achievement'); const text = validateInput(input.value, 'æˆå°±å†…å®¹'); if (text === null) return;const datetime = getCurrentDateTime();const achievement = { id: generateId(), text: safeTextInput(text), date: datetime.date, time: datetime.time, timestamp: datetime.timestamp, modificationHistory: []}; appData.achievements.unshift(achievement); input.value = ''; localStorage.removeItem('input_new-achievement'); saveData(); renderAchievements(); checkRecordDays();} function highlightText(text, keyword) { if (!keyword || !text) return text; const keywords = keyword.split(/\s+/).filter(word => word.length > 0); if (keywords.length === 0) return text; let highlightedText = text.toString(); keywords.forEach(keyword => { try { const regex = new RegExp(`(${keyword})`, 'gi'); highlightedText = highlightedText.replace(regex, '<span class="highlight">$1</span>'); } catch (e) { const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); const regex = new RegExp(`(${escapedKeyword})`, 'gi'); highlightedText = highlightedText.replace(regex, '<span class="highlight">$1</span>'); } }); return highlightedText; }function groupItemsByDate(items) { const grouped = {}; items.forEach(item => { const date = item.date; if (!grouped[date]) { grouped[date] = []; } grouped[date].push(item); }); const sortedDates = Object.keys(grouped).sort((a, b) => { return new Date(b) - new Date(a); }); return { grouped, sortedDates };}function renderAchievements() { const list = document.getElementById('achievements-list'); const fragment = document.createDocumentFragment(); const searchStatus = document.getElementById('search-status'); const searchStatusText = document.getElementById('search-status-text'); if (appData.achievements.length === 0) { return; }const { grouped: achievementsByDate, sortedDates } = groupItemsByDate(appData.achievements); sortedDates.forEach(date => { const achievements = achievementsByDate[date].sort((a, b) => { const timeA = parseTimeString(a.time); const timeB = parseTimeString(b.time); return timeA - timeB; }); function parseTimeString(timeStr) { const [time, modifier] = timeStr.split(' '); let [hours, minutes] = time.split(':').map(Number); if (modifier === 'PM' && hours < 12) hours += 12; if (modifier === 'AM' && hours === 12) hours = 0; return hours * 60 + minutes; } const isCollapsed = collapseState.achievements[date] || false; const item = document.createElement('div'); item.className = 'achievement-item'; if (isCollapsed) { item.classList.add('collapsed'); } let achievementsHTML = ''; achievements.forEach((achievement, index) => { const isVisible = isItemVisible(achievement, date); if (!isVisible) return; let modificationHistoryHTML = ''; if (achievement.modificationHistory && achievement.modificationHistory.length > 0) { const recentModifications = achievement.modificationHistory.slice(-3); modificationHistoryHTML = ` <div class="modification-history"> ä¿®æ”¹å†å²: ${recentModifications.map(mod => `${mod.date} ${mod.time}` ).join(', ')} </div> `; } const highlightedText = highlightText(restoreTextDisplay(achievement.text), searchKeyword); const highlightedDate = highlightText(achievement.date, searchKeyword); const highlightedTime = highlightText(achievement.time, searchKeyword); achievementsHTML += ` <div class="achievement-entry"> <div class="achievement-text"> ${index + 1}. ${highlightedText} <span class="achievement-time">${highlightedTime}</span> ${modificationHistoryHTML} </div> <div class="achievement-controls"> <button class="btn-edit" onclick="openEditModal('achievement', ${achievement.id})">ä¿®æ”¹</button> <button class="btn-danger" onclick="deleteItem('achievement', ${achievement.id})">åˆ é™¤</button> </div> </div> `; }); if (!achievementsHTML) return; item.innerHTML = ` <div class="achievement-date" onclick="toggleCollapse('achievements', '${date}')"> <span>${highlightText(date, searchKeyword)}</span> <span class="collapse-icon">â–¼</span> </div> <div class="collapsible-content"> <div class="achievement-list"> ${achievementsHTML} </div> </div> `; fragment.appendChild(item); });list.innerHTML = '';list.appendChild(fragment); } function isItemVisible(item, date) { if (dateFilter) { const itemDate = new Date(item.date); if (typeof dateFilter === 'string') { const filterDate = new Date(dateFilter); if (itemDate.toDateString() !== filterDate.toDateString()) return false; } else if (dateFilter.type === 'month') { const filterDate = new Date(dateFilter.value + '-01'); if (itemDate.getFullYear() !== filterDate.getFullYear() || itemDate.getMonth() !== filterDate.getMonth()) { return false; } } else if (dateFilter.type === 'year') { if (itemDate.getFullYear() !== parseInt(dateFilter.value)) { return false; } } else if (dateFilter.type === 'range') { const startDate = new Date(dateFilter.start); const endDate = new Date(dateFilter.end); endDate.setHours(23, 59, 59, 999); if (itemDate < startDate || itemDate > endDate) { return false; } } } if (!searchKeyword) return true; const keywords = searchKeyword.split(/\s+/).filter(word => word.length > 0); if (keywords.length === 0) return true; const searchableText = [ item.text, item.date, item.time, item.category, item.name, item.content ].filter(Boolean).join(' ').toLowerCase(); return keywords.every(keyword => { const lowerKeyword = keyword.toLowerCase(); try { const regex = new RegExp(lowerKeyword, 'i'); return regex.test(searchableText); } catch (e) { return searchableText.includes(lowerKeyword); } }); }function isSkillVisible(skill) { if (searchKeyword) { const keyword = searchKeyword.toLowerCase(); const nameMatch = skill.name.toLowerCase().includes(keyword); let checkinMatch = false; let matchedCheckins = []; skill.checkins.forEach(checkin => { if (checkin.content.toLowerCase().includes(keyword) || checkin.date.toLowerCase().includes(keyword)) { checkinMatch = true; matchedCheckins.push(checkin.id); } }); if (nameMatch || checkinMatch) { skill._matchedCheckins = matchedCheckins; return true; } return false; } if (dateFilter) { let hasVisibleCheckins = false; skill.checkins.forEach(checkin => { const checkinDate = new Date(checkin.date); if (typeof dateFilter === 'string') { const filterDate = new Date(dateFilter); if (checkinDate.toDateString() === filterDate.toDateString()) { hasVisibleCheckins = true; } } else if (dateFilter.type === 'month') { const filterDate = new Date(dateFilter.value + '-01'); if (checkinDate.getFullYear() === filterDate.getFullYear() && checkinDate.getMonth() === filterDate.getMonth()) { hasVisibleCheckins = true; } } else if (dateFilter.type === 'year') { if (checkinDate.getFullYear() === parseInt(dateFilter.value)) { hasVisibleCheckins = true; } } else if (dateFilter.type === 'range') { const startDate = new Date(dateFilter.start); const endDate = new Date(dateFilter.end); endDate.setHours(23, 59, 59, 999); if (checkinDate >= startDate && checkinDate <= endDate) { hasVisibleCheckins = true; } } }); return hasVisibleCheckins; } return true;} function toggleCollapse(type, key) { if (!collapseState[type]) { collapseState[type] = {}; } collapseState[type][key] = !collapseState[type][key]; if (type === 'achievements') { renderAchievements(); } else if (type === 'skills') { renderSkills(); } else if (type === 'reflection') { renderReflections(); } else if (type === 'value') { renderValueOutputs(); } } function toggleAllCollapsible(type) { if (!collapseState[type]) { collapseState[type] = {}; } let hasExpanded = false; Object.values(collapseState[type]).forEach(state => { if (!state) hasExpanded = true; }); if (Object.keys(collapseState[type]).length === 0) { hasExpanded = true; } if (type === 'achievements') { const achievementsByDate = {}; appData.achievements.forEach(achievement => { const date = achievement.date; achievementsByDate[date] = true; }); Object.keys(achievementsByDate).forEach(date => { collapseState.achievements[date] = hasExpanded; }); } else if (type === 'skills') { appData.skills.forEach(skill => { collapseState.skills[skill.id] = hasExpanded; }); } else if (type === 'reflection') { const reflectionsByDate = {}; appData.reflections.forEach(reflection => { const date = reflection.date; reflectionsByDate[date] = true; }); Object.keys(reflectionsByDate).forEach(date => { collapseState.reflection[date] = hasExpanded; }); } else if (type === 'value') { const outputsByCategory = {}; appData.valueOutputs.forEach(output => { const category = output.category; outputsByCategory[category] = true; }); Object.keys(outputsByCategory).forEach(category => { collapseState.value[category] = hasExpanded; }); } if (type === 'achievements') { renderAchievements(); } else if (type === 'skills') { renderSkills(); } else if (type === 'reflection') { renderReflections(); } else if (type === 'value') { renderValueOutputs(); } }function showSkillActionModal() { const input = document.getElementById('new-skill'); const text = validateInput(input.value, 'æŠ€èƒ½åç§°æˆ–æ‰“å¡å†…å®¹'); if (text === null) { input.focus(); return; } if (!text) { alert('è¯·è¾“å…¥æŠ€èƒ½åç§°æˆ–æ‰“å¡å†…å®¹'); input.focus(); return; } const select = document.getElementById('skill-action-select'); select.innerHTML = '<option value="new">æ–°æŠ€èƒ½</option>'; appData.skills.forEach(skill => { const option = document.createElement('option'); option.value = skill.id; option.textContent = skill.name; select.appendChild(option); }); document.getElementById('skill-action-modal').style.display = 'flex';}function processSkillAction() { const select = document.getElementById('skill-action-select'); const selectedValue = select.value; const input = document.getElementById('new-skill'); const text = input.value.trim(); if (selectedValue === 'new') { addSkill(text); input.value = ''; localStorage.removeItem('input_new-skill'); } else { const skillId = parseInt(selectedValue); const skill = appData.skills.find(s => s.id === skillId); if (skill) { const now = new Date(); const checkin = { id: generateId(), content: text, date: now.toLocaleDateString(), time: now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}), timestamp: now.getTime(), modificationHistory: [] }; skill.checkins.unshift(checkin); saveData(); renderSkills(); checkRecordDays(); input.value = ''; localStorage.removeItem('input_new-skill'); } } closeModal('skill-action-modal');} function addSkill(skillName) { const text = skillName || document.getElementById('new-skill').value.trim(); if (text) { if (appData.skills.some(skill => skill.name === text)) { alert('å·²å­˜åœ¨åŒåæŠ€èƒ½'); return; } const skill = { id: generateId(), name: text, progress: 0, checkins: [], category: 'want' }; appData.skills.push(skill); document.getElementById('new-skill').value = ''; saveData(); skillCategoryFilter = 'all'; updateSkillCategoryButtons(); renderSkills(); } else { alert('è¯·è¾“å…¥æŠ€èƒ½åç§°'); } } function renderSkills() { const list = document.getElementById('skills-list'); const fragment = document.createDocumentFragment(); const skillCategoryButtons = document.querySelectorAll('.skill-category-button'); updateSkillCategoryButtons(); appData.skills.sort((a, b) => { const aLatest = a.checkins.length > 0 ? Math.max(...a.checkins.map(c => c.timestamp)) : a.id; const bLatest = b.checkins.length > 0 ? Math.max(...b.checkins.map(c => c.timestamp)) : b.id; return bLatest - aLatest; }); if (appData.skills.length === 0) { return; } let filteredSkills = appData.skills; if (skillCategoryFilter !== 'all') { filteredSkills = appData.skills.filter(skill => skill.category === skillCategoryFilter); } filteredSkills = filteredSkills.filter(skill => isSkillVisible(skill)); if (filteredSkills.length === 0) { const emptyState = document.createElement('div'); emptyState.className = 'empty-state'; emptyState.textContent = 'æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æŠ€èƒ½è®°å½•'; list.appendChild(emptyState); return; } filteredSkills.forEach(skill => {let progressValue, progressText;if (skill.progressType === 'count') { progressValue = Math.min(skill.checkins.length, 100); progressText = `è¿›åº¦: ${skill.checkins.length}/100æ¡`;} else { const uniqueDays = new Set(skill.checkins.map(checkin => checkin.date)).size; progressValue = Math.min(uniqueDays, 100); progressText = `è¿›åº¦: ${uniqueDays}/100å¤©`;}skill.progress = progressValue; if (skill.progress >= 100 && skill.category !== 'completed') { skill.category = 'completed'; saveData(); } const isCollapsed = collapseState.skills[skill.id] || false; const item = document.createElement('div'); item.className = 'skill-item'; if (skill.category === 'completed') { item.classList.add('skill-category-completed'); } else if (skill.category === 'focus') { item.classList.add('skill-category-focus'); } else { item.classList.add('skill-category-want'); } if (isCollapsed) { item.classList.add('collapsed'); }const { grouped: checkinsByDate, sortedDates } = groupItemsByDate(skill.checkins); let checkinsHTML = ''; sortedDates.forEach(date => { const dayCheckins = checkinsByDate[date].sort((a, b) => { return a.timestamp - b.timestamp; }); let dayCheckinsHTML = `<div class="achievement-date"><span>${highlightText(date, searchKeyword)}</span></div>`; dayCheckins.forEach((checkin, index) => { const isVisible = isItemVisible(checkin, date); if (!isVisible) return; let modificationHistoryHTML = ''; if (checkin.modificationHistory && checkin.modificationHistory.length > 0) { const recentModifications = checkin.modificationHistory.slice(-3); modificationHistoryHTML = ` <div class="modification-history"> ä¿®æ”¹å†å²: ${recentModifications.map(mod => `${mod.date} ${mod.time}` ).join(', ')} </div> `; } const highlightedContent = highlightText(checkin.content, searchKeyword); const highlightedTime = highlightText(checkin.time, searchKeyword); dayCheckinsHTML += ` <div class="achievement-entry"> <div class="achievement-text"> <span>${index + 1}. </span> <span class="checkin-text">${highlightedContent}</span> <span class="achievement-time">${highlightedTime}</span> ${modificationHistoryHTML} </div> <div class="achievement-controls"> <button class="btn-edit" onclick="openEditModal('checkin', ${checkin.id}, ${skill.id})">ä¿®æ”¹</button> <button class="btn-danger" onclick="deleteItem('checkin', ${checkin.id}, ${skill.id})">åˆ é™¤</button> </div> </div> `; }); if (dayCheckinsHTML !== `<div class="achievement-date">${highlightText(date, searchKeyword)}</div>`) { checkinsHTML += dayCheckinsHTML; } }); const highlightedSkillName = highlightText(skill.name, searchKeyword); let categoryLabel = ''; if (skill.category === 'completed') { categoryLabel = '<span class="skill-category-label category-completed" onclick="event.stopPropagation(); cycleSkillCategory(' + skill.id + ')">å·²å®Œæˆ</span>'; } else if (skill.category === 'focus') { categoryLabel = '<span class="skill-category-label category-focus" onclick="event.stopPropagation(); cycleSkillCategory(' + skill.id + ')">è¿‘æœŸé‡ç‚¹</span>'; } else { categoryLabel = '<span class="skill-category-label category-want" onclick="event.stopPropagation(); cycleSkillCategory(' + skill.id + ')">æƒ³å­¦</span>'; } item.innerHTML = ` <div class="skill-header" onclick="toggleCollapse('skills', ${skill.id})"> <h3>${highlightedSkillName} ${categoryLabel}</h3> <div class="skill-header-controls"> <span class="collapse-icon">â–¼</span> <button class="btn-edit" onclick="openEditModal('skill', ${skill.id})">æ”¹å</button> <button class="btn-danger" onclick="deleteItem('skill', ${skill.id})">åˆ é™¤</button> </div> </div> <div class="collapsible-content"><div class="progress-bar" onclick="toggleProgressType(${skill.id})" style="cursor: pointer;" title="ç‚¹å‡»åˆ‡æ¢ç»Ÿè®¡æ–¹å¼"> <div class="progress" style="width: ${progressValue}%"></div></div><p onclick="toggleProgressType(${skill.id})" style="cursor: pointer; margin: 5px 0;" title="ç‚¹å‡»åˆ‡æ¢ç»Ÿè®¡æ–¹å¼">${progressText}</p> <div class="skill-controls"> <button onclick="openCheckinModal(${skill.id})">æ‰“å¡</button> </div> ${skill.checkins.length > 0 ? `<div class="achievement-list" style="margin-top: 15px;">${checkinsHTML}</div>` : ''} </div> `; fragment.appendChild(item);}); list.innerHTML = '';list.appendChild(fragment); }function toggleProgressType(skillId) { const skill = appData.skills.find(s => s.id === skillId); if (skill) { skill.progressType = skill.progressType === 'days' ? 'count' : 'days'; saveData(); renderSkills(); }} function updateSkillCategoryButtons() { document.querySelectorAll('.skill-category-button').forEach(button => { button.classList.remove('active'); if (button.getAttribute('data-category') === skillCategoryFilter) { button.classList.add('active'); } });} function cycleSkillCategory(skillId) { const skill = appData.skills.find(s => s.id === skillId); if (skill) { const categoryCycle = { 'want': 'focus', 'focus': 'completed', 'completed': 'want' }; skill.category = categoryCycle[skill.category] || 'want'; saveData(); renderSkills(); } } function openCheckinModal(skillId) { currentSkillId = skillId; const skill = appData.skills.find(s => s.id === skillId); document.getElementById('checkin-skill-name').textContent = `ä¸º"${skill.name}"æ‰“å¡`; document.getElementById('checkin-content').value = ''; document.getElementById('checkin-modal').style.display = 'flex'; }function submitCheckin() { const content = validateInput(document.getElementById('checkin-content').value, 'æ‰“å¡å†…å®¹'); if (content === null) return; if (!currentSkillId) { alert('æœªé€‰æ‹©æŠ€èƒ½'); return; } const skill = appData.skills.find(s => s.id === currentSkillId); if (skill) { const uniqueDays = new Set(skill.checkins.map(checkin => checkin.date)).size; if (uniqueDays >= 100) { alert('è¯¥æŠ€èƒ½å·²è¾¾åˆ°100å¤©æ‰“å¡ï¼Œå·²å®Œæˆå­¦ä¹ ç›®æ ‡ï¼'); } const datetime = getCurrentDateTime();const checkin = { id: generateId(), content: content, date: datetime.date, time: datetime.time, timestamp: datetime.timestamp, modificationHistory: []}; skill.checkins.unshift(checkin); saveData(); renderSkills(); closeModal('checkin-modal'); checkRecordDays(); appData.skills.sort((a, b) => { const aLatest = a.checkins.length > 0 ? Math.max(...a.checkins.map(c => c.timestamp)) : a.id; const bLatest = b.checkins.length > 0 ? Math.max(...b.checkins.map(c => c.timestamp)) : b.id; return bLatest - aLatest; }); renderSkills(); } }function saveReflection() { const textarea = document.getElementById('reflection-text'); const text = validateInput(textarea.value, 'åæ€å†…å®¹'); if (text === null) return; if (text) {const datetime = getCurrentDateTime();const reflection = { id: generateId(), text: text, date: datetime.date, time: datetime.time, timestamp: datetime.timestamp, modificationHistory: []}; appData.reflections.unshift(reflection); textarea.value = ''; localStorage.removeItem('input_reflection-text'); saveData(); renderReflections(); checkRecordDays(); } else { alert('è¯·è¾“å…¥åæ€å†…å®¹'); } }function insertDiaryTemplate() {
    const template = `ã€Œå¾®å…‰æˆé•¿æ—¥è®°ã€
ğŸŒ± ä»Šæ—¥å¾®å…‰æ—¶åˆ»
ä»Šå¤©ï¼Œæˆ‘ç•™æ„åˆ°ï¼šï¼ˆè®°å½•ä¸€ä»¶å…·ä½“çš„å°äº‹ï¼‰
è¿™è®©æˆ‘æ„Ÿè§‰ï¼š ï¼ˆæè¿°å½“æ—¶çš„ç»†å¾®æ„Ÿå—ï¼Œå¦‚â€œå¿ƒé‡Œæš–äº†ä¸€ä¸‹â€ã€â€œæ¾äº†å£æ°”â€ã€â€œæœ‰ç‚¹å°å¾—æ„â€ï¼‰

âœ¨ æˆ‘çš„è¿›æ­¥ç—•è¿¹
ï¼ˆå¯è‡ªè¡Œåˆ æ”¹ï¼‰
å°è¯•äº†æ–°äº‹ç‰©ï¼ˆå“ªæ€•åªæ˜¯æ¢æ¡è·¯å›å®¶ã€å°ä¸€é“æ–°èœï¼‰
å¤šäº†ä¸€ç‚¹è€å¿ƒï¼ˆå¯¹è‡ªå·±ã€å¯¹ä»–äººã€å¯¹æŸä»¶äº‹ï¼‰
å¸æ”¶äº†ä¸€ç‚¹æ–°çŸ¥ï¼ˆçœ‹äº†ä¸€é¡µä¹¦ã€å­¦åˆ°ä¸€ä¸ªå†·çŸ¥è¯†ã€æœ‰äº†ä¸€ç‚¹å°æ„Ÿæ‚Ÿï¼‰
å¿ƒæ€æ›´æ¾å¼›äº†ï¼ˆæ”¾è¿‡äº†ä¸€ä»¶å°äº‹ã€ä¸å†çº ç»“æŸä¸ªé—®é¢˜ï¼‰
è¡ŒåŠ¨åŠ›+1ï¼ˆåŠ¨æ‰‹å¤„ç†äº†ä¸€ä»¶æ‹–å»¶çš„å°äº‹ï¼‰
ä¼ é€’äº†ä¸€ç‚¹å–„æ„ï¼ˆä¸€ä¸ªå¾®ç¬‘ã€ä¸€å¥æ„Ÿè°¢ã€ä¸€æ¬¡éšæ‰‹å¸®åŠ©ï¼‰
ç…§é¡¾å¥½äº†è‡ªå·±ï¼ˆå¥½å¥½åƒé¥­ã€åŠæ—¶ä¼‘æ¯ã€å…è®¸è‡ªå·±æ”¾æ¾ï¼‰

è¿›æ­¥å°ç»“ï¼š ä»Šå¤©æˆ‘æ”¶è·äº† ____ ä¸ªå°å°çš„è¿›æ­¥ç—•è¿¹ã€‚

ğŸ’­ ä¸€å¿µä¹‹è½¬
ï¼ˆå¦‚æœä»Šå¤©æœ‰æ„Ÿåˆ°å›°æ‰°æˆ–è‡ªè´£çš„æ—¶åˆ»ï¼Œè¯•ç€ç”¨ä¸€ä¸ªæ–°çš„è§’åº¦çœ‹çœ‹å®ƒï¼Ÿå¯é€‰å¡«ï¼Œä¸è¯„åˆ¤è‡ªå·±ï¼‰
å›°æ‰°æˆ‘çš„å°äº‹ï¼š
æˆ‘å°è¯•æ¢ä¸ªè§’åº¦çœ‹ï¼š

ğŸŒŸ æ˜æ—¥å°æœŸå¾…
ï¼ˆä¸ºæ˜å¤©è®¾å®šä¸€ä¸ªç®€å•ã€è½»æ¾ã€æ— å‹åŠ›çš„å°æœŸå¾…ï¼Œè®©ç”Ÿæ´»æœ‰ç›¼å¤´ï¼‰
æˆ‘æœ‰ç‚¹æœŸå¾…æ˜å¤©ï¼šï¼ˆå¦‚ï¼šæ›´æ–°çš„æ’­å®¢ã€æ™šä¸Šè¦çœ‹çš„å‰§ã€æ•£æ­¥æ—¶çš„å¾®é£ï¼‰


`; const textarea = document.getElementById('reflection-text'); textarea.value = template; textarea.focus();} function renderReflections() { const list = document.getElementById('reflection-list'); const fragment = document.createDocumentFragment(); if (appData.reflections.length === 0) { return; }const { grouped: reflectionsByDate, sortedDates } = groupItemsByDate(appData.reflections); sortedDates.forEach(date => { const reflections = reflectionsByDate[date]; const isCollapsed = collapseState.reflection[date] || false; const item = document.createElement('div'); item.className = 'reflection-item'; if (isCollapsed) { item.classList.add('collapsed'); } let reflectionsHTML = ''; reflections.forEach(reflection => { const isVisible = isItemVisible(reflection, date); if (!isVisible) return; let modificationHistoryHTML = ''; if (reflection.modificationHistory && reflection.modificationHistory.length > 0) { const recentModifications = reflection.modificationHistory.slice(-3); modificationHistoryHTML = ` <div class="modification-history"> ä¿®æ”¹å†å²: ${recentModifications.map(mod => `${mod.date} ${mod.time}` ).join(', ')} </div> `; } const highlightedText = highlightText(reflection.text, searchKeyword); const highlightedTime = highlightText(reflection.time, searchKeyword); const firstSentence = reflection.text.split(/[ï¼Œã€‚ï¼ï¼Ÿ\n.,]/)[0].trim(); const title = firstSentence || reflection.text.substring(0, 30) + (reflection.text.length > 30 ? '...' : ''); const firstLine = reflection.text.split('\n')[0].trim(); const isTitleCompleteFirstLine = (title === firstLine); let displayText = highlightedText; if (isTitleCompleteFirstLine) { const lines = reflection.text.split('\n'); if (lines.length > 1) { displayText = highlightText(lines.slice(1).join('\n'), searchKeyword); } else { displayText = ''; } } reflectionsHTML += ` <div class="reflection-title">${title}</div> <div class="reflection-content"> ${displayText ? `<div class="reflection-text">${displayText}</div>` : ''} </div> <div class="reflection-meta"> <div style="color: #888; font-size: 0.8rem;">è®°å½•æ—¶é—´: ${highlightedTime}</div> ${modificationHistoryHTML} <div class="skill-controls"> <button class="btn-edit" onclick="openEditModal('reflection', ${reflection.id})">ä¿®æ”¹</button> <button class="btn-danger" onclick="deleteItem('reflection', ${reflection.id})">åˆ é™¤</button> </div> </div> `; }); if (!reflectionsHTML) return; item.innerHTML = ` <div class="achievement-date" onclick="toggleCollapse('reflection', '${date}')"> <span>${highlightText(date, searchKeyword)}</span> <span class="collapse-icon">â–¼</span> </div> <div class="collapsible-content"> ${reflectionsHTML} </div> `; fragment.appendChild(item);}); list.innerHTML = '';list.appendChild(fragment); }function addValueOutput(type) { let inputId, categoryName; switch(type) { case 'share': inputId = 'new-share'; categoryName = 'çŸ¥è¯†åˆ†äº«'; break; case 'project': inputId = 'new-project'; categoryName = 'å®Œæˆå°é¡¹ç›®'; break; case 'help': inputId = 'new-help'; categoryName = 'æä¾›æ— å¿å¸®åŠ©'; break; case 'partnership': inputId = 'new-partnership'; categoryName = 'å¤–éƒ¨æ”¯æŒä¸åé¦ˆ'; break; default: return; } const input = document.getElementById(inputId); const text = validateInput(input.value, categoryName); if (text === null) return; if (text) {const datetime = getCurrentDateTime();const valueOutput = { id: generateId(), type: type, category: categoryName, text: text, date: datetime.date, time: datetime.time, timestamp: datetime.timestamp, modificationHistory: []}; appData.valueOutputs.unshift(valueOutput); input.value = ''; localStorage.removeItem(`input_${inputId}`); saveData(); renderValueOutputs(); checkRecordDays(); } else { alert('è¯·è¾“å…¥å†…å®¹'); } } function renderValueOutputs() { const list = document.getElementById('value-outputs-list'); const fragment = document.createDocumentFragment(); if (appData.valueOutputs.length === 0) { return; } const outputsByCategory = {}; appData.valueOutputs.forEach(output => { const category = output.category; if (!outputsByCategory[category]) { outputsByCategory[category] = []; } outputsByCategory[category].push(output); }); Object.keys(outputsByCategory).forEach(category => { const outputs = outputsByCategory[category]; const isCollapsed = collapseState.value[category] || false; const item = document.createElement('div'); item.className = 'value-output-item'; if (isCollapsed) { item.classList.add('collapsed'); } let outputsHTML = ''; outputs.forEach((output, index) => { const isVisible = isItemVisible(output, output.date); if (!isVisible) return; let modificationHistoryHTML = ''; if (output.modificationHistory && output.modificationHistory.length > 0) { const recentModifications = output.modificationHistory.slice(-3); modificationHistoryHTML = ` <div class="modification-history"> ä¿®æ”¹å†å²: ${recentModifications.map(mod => `${mod.date} ${mod.time}` ).join(', ')} </div> `; } const highlightedText = highlightText(output.text, searchKeyword); const highlightedCategory = highlightText(output.category, searchKeyword); const highlightedDate = highlightText(output.date, searchKeyword); const highlightedTime = highlightText(output.time, searchKeyword); outputsHTML += `<div class="value-output-entry"> <div class="value-output-content"> <div class="achievement-entry"> <div class="achievement-text"> <span>${index + 1}. </span> <span class="value-text">${highlightedText}</span> </div> </div> </div> <div class="value-output-meta"> <div style="margin-bottom: 8px; font-size: 0.85rem; color: #666;"> <span>${highlightedDate} ${highlightedTime}</span> </div> ${modificationHistoryHTML} <div class="achievement-controls" style="margin-top: 8px;"> <button class="btn-edit" onclick="openEditModal('value', ${output.id})">ä¿®æ”¹</button> <button class="btn-danger" onclick="deleteItem('value', ${output.id})">åˆ é™¤</button> </div> </div></div>`; }); if (!outputsHTML) return; const highlightedCategory = highlightText(category, searchKeyword); item.innerHTML = ` <div class="value-output-header" onclick="toggleCollapse('value', '${category}')"> <h3>${highlightedCategory}</h3> <div class="value-output-header-controls"> <span class="collapse-icon">â–¼</span> </div> </div> <div class="collapsible-content"> ${outputsHTML} </div> `; fragment.appendChild(item);}); list.innerHTML = '';list.appendChild(fragment); }function deleteItem(type, id, skillId = null) { const config = { achievement: { message: 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæˆå°±å—ï¼Ÿ', data: 'achievements', render: renderAchievements }, reflection: { message: 'ç¡®å®šè¦åˆ é™¤è¿™æ¡åæ€å—ï¼Ÿ', data: 'reflections', render: renderReflections }, checkin: { message: 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ‰“å¡è®°å½•å—ï¼Ÿ', render: renderSkills }, skill: { message: 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæŠ€èƒ½å—ï¼Ÿ', data: 'skills', render: renderSkills }, value: { message: 'ç¡®å®šè¦åˆ é™¤è¿™æ¡ä»·å€¼è¾“å‡ºå—ï¼Ÿ', data: 'valueOutputs', render: renderValueOutputs } }; const itemConfig = config[type]; if (!itemConfig) { console.error('æœªçŸ¥çš„åˆ é™¤ç±»å‹:', type); return; } if (confirm(itemConfig.message)) { let success = false; if (type === 'checkin') { if (skillId) { const skill = appData.skills.find(s => s.id === skillId); if (skill) { skill.checkins = skill.checkins.filter(c => c.id !== id); success = true; } } } else { appData[itemConfig.data] = appData[itemConfig.data].filter(item => item.id !== id); success = true; } if (success) { saveData(); checkRecordDays(); itemConfig.render(); } }} function getDateRange() { let earliest = null; let latest = null; appData.achievements.forEach(achievement => { const date = new Date(achievement.date); if (!earliest || date < earliest) earliest = date; if (!latest || date > latest) latest = date; }); appData.skills.forEach(skill => { skill.checkins.forEach(checkin => { const date = new Date(checkin.date); if (!earliest || date < earliest) earliest = date; if (!latest || date > latest) latest = date; }); }); appData.reflections.forEach(reflection => { const date = new Date(reflection.date); if (!earliest || date < earliest) earliest = date; if (!latest || date > latest) latest = date; }); appData.valueOutputs.forEach(valueOutput => { const date = new Date(valueOutput.date); if (!earliest || date < earliest) earliest = date; if (!latest || date > latest) latest = date; }); function formatDate(date) { if (!date) return ''; const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; } return { earliest: formatDate(earliest), latest: formatDate(latest) }; } function showEnhancedExportModal() { const dateRange = getDateRange(); document.getElementById('export-start-date').value = dateRange.earliest; document.getElementById('export-end-date').value = dateRange.latest; document.querySelectorAll('.export-category-checkbox').forEach(checkbox => { checkbox.checked = true; }); currentExportFormat = 'json'; document.getElementById('preview-json-btn').classList.add('active'); document.getElementById('preview-md-btn').classList.remove('active'); document.getElementById('enhanced-export-modal').style.display = 'flex'; updateExportPreview(); document.querySelectorAll('.export-category-checkbox').forEach(checkbox => { checkbox.addEventListener('change', updateExportPreview); }); document.getElementById('export-start-date').addEventListener('change', updateExportPreview); document.getElementById('export-end-date').addEventListener('change', updateExportPreview); } function copyExportFilename() { const filenameInput = document.getElementById('export-filename-display'); filenameInput.select(); document.execCommand('copy'); } function switchPreviewFormat(format) { currentExportFormat = format; document.getElementById('preview-json-btn').classList.toggle('active', format === 'json'); document.getElementById('preview-md-btn').classList.toggle('active', format === 'md'); updateExportPreview(); } function updateExportPreview() { const exportData = generateExportData(); if (currentExportFormat === 'json') { document.getElementById('enhanced-export-data').value = JSON.stringify(exportData, null, 2); } else { const markdownContent = generateMarkdownData(exportData); document.getElementById('enhanced-export-data').value = markdownContent; } const dateRange = getExportDateRange(exportData); const counts = getExportCounts(exportData); let fileName = 'æ­£åé¦ˆ'; fileName += `_${dateRange.display}`; if (currentExportFormat === 'json') { fileName += `_${counts.achievements}æˆå°±+${counts.skills}æŠ€èƒ½+${counts.reflections}åæ€+${counts.valueOutputs}åˆ›é€ .json`; } else { fileName += `_${counts.achievements}ach+${counts.skills}skl+${counts.reflections}ref+${counts.valueOutputs}val.md`; } document.getElementById('export-filename-display').value = fileName; } function generateExportData() { const startDateInput = document.getElementById('export-start-date').value; const endDateInput = document.getElementById('export-end-date').value; const includeAchievements = document.getElementById('export-achievements').checked; const includeSkills = document.getElementById('export-skills').checked; const includeReflections = document.getElementById('export-reflections').checked; const includeValueOutputs = document.getElementById('export-value').checked; const exportData = { achievements: [], skills: [], reflections: [], valueOutputs: [], recordData: { recordDays: 0, recordDates: [] }, exportInfo: { exportedAt: new Date().toISOString(), dateRange: { start: startDateInput, end: endDateInput }, categories: { achievements: includeAchievements, skills: includeSkills, reflections: includeReflections, valueOutputs: includeValueOutputs } } }; let start, end; if (startDateInput && endDateInput) { start = new Date(startDateInput); start.setHours(0,0,0,0); end = new Date(endDateInput); end.setHours(23,59,59,999); }if (includeAchievements) { exportData.achievements = filterByDateRange(appData.achievements, startDateInput, endDateInput);} if (includeSkills) { exportData.skills = appData.skills.map(skill => { return { ...skill, checkins: filterByDateRange(skill.checkins, startDateInput, endDateInput) }; });} if (includeReflections) { exportData.reflections = filterByDateRange(appData.reflections, startDateInput, endDateInput);} if (includeValueOutputs) { exportData.valueOutputs = filterByDateRange(appData.valueOutputs, startDateInput, endDateInput);} if (startDateInput && endDateInput) { exportData.recordData.recordDates = appData.recordData.recordDates.filter(date => { const recordDate = new Date(date); return recordDate >= start && recordDate <= end; }); } else { exportData.recordData.recordDates = [...appData.recordData.recordDates]; } exportData.recordData.recordDays = exportData.recordData.recordDates.length; return exportData; } function getExportDateRange(exportData) { let earliest = null; let latest = null; exportData.achievements.forEach(item => { const date = new Date(item.date); if (!earliest || date < earliest) earliest = date; if (!latest || date > latest) latest = date; }); exportData.skills.forEach(skill => { skill.checkins.forEach(checkin => { const date = new Date(checkin.date); if (!earliest || date < earliest) earliest = date; if (!latest || date > latest) latest = date; }); }); exportData.reflections.forEach(item => { const date = new Date(item.date); if (!earliest || date < earliest) earliest = date; if (!latest || date > latest) latest = date; }); exportData.valueOutputs.forEach(item => { const date = new Date(item.date); if (!earliest || date < earliest) earliest = date; if (!latest || date > latest) latest = date; }); function formatDate(date) { if (!date) return 'æœªçŸ¥æ—¥æœŸ'; const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return `${year}${month}${day}`; } function formatDateForDisplay(date) { if (!date) return ''; const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return { year: year, month: month, day: day, full: `${year}${month}${day}` }; } const earliestFormatted = formatDateForDisplay(earliest); const latestFormatted = formatDateForDisplay(latest); return { earliest: earliestFormatted.full, latest: latestFormatted.full, display: earliest && latest ? (earliestFormatted.year === latestFormatted.year ? `${earliestFormatted.year}${earliestFormatted.month}${earliestFormatted.day}-${latestFormatted.month}${latestFormatted.day}` : `${earliestFormatted.full}-${latestFormatted.full}`) : (earliestFormatted.full || latestFormatted.full || 'æ— æ—¥æœŸ') }; } function getExportCounts(exportData) { return { achievements: exportData.achievements.length, skills: exportData.skills.length, reflections: exportData.reflections.length, valueOutputs: exportData.valueOutputs.length }; } function generateMarkdownData(exportData) { const dateRange = getExportDateRange(exportData); const counts = getExportCounts(exportData); let markdown = '---\n'; markdown += `title: "æ­£åé¦ˆæˆé•¿è®°å½• - ${dateRange.display}"\n`; markdown += `created: "${new Date().toISOString()}"\n`; markdown += `date_range: "${dateRange.earliest} è‡³ ${dateRange.latest}"\n`; markdown += `year: "${dateRange.earliest.substring(0,4)}"\n`; markdown += `export_source: "æ­£åé¦ˆæˆé•¿åŠ©æ‰‹"\n`; markdown += `tags: ["æ­£åé¦ˆ", "æˆé•¿è®°å½•", "ä¸ªäººå‘å±•", "${dateRange.earliest.substring(0,4)}å¹´"]\n`; markdown += '---\n\n'; markdown += `# æ­£åé¦ˆæˆé•¿è®°å½•\n\n`; markdown += `> è®°å½•æ—¶é—´ï¼š${dateRange.earliest} è‡³ ${dateRange.latest}\n\n`; markdown += `## ğŸ“Š ç»Ÿè®¡æ¦‚è§ˆ\n\n`; markdown += `- **æˆå°±è®°å½•**: ${counts.achievements} æ¡\n`; markdown += `- **æŠ€èƒ½è¿½è¸ª**: ${counts.skills} é¡¹\n`; markdown += `- **è‡ªæˆ‘å¯¹è¯**: ${counts.reflections} æ¡\n`; markdown += `- **ä»·å€¼è¾“å‡º**: ${counts.valueOutputs} æ¡\n\n`; if (exportData.achievements.length > 0) { markdown += `## ğŸŒŸ æ¯æ—¥æˆå°±\n\n`; const { grouped: achievementsByDate } = groupItemsByDate(exportData.achievements); Object.keys(achievementsByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => { markdown += `### ${date}\n\n`; achievementsByDate[date].forEach((achievement, index) => { markdown += `${index + 1}. ${achievement.text} _${achievement.time}_\n`; if (achievement.modificationHistory && achievement.modificationHistory.length > 0) { markdown += ` - ä¿®æ”¹è®°å½•: ${achievement.modificationHistory.map(mod => `${mod.date} ${mod.time}`).join(', ')}\n`; } }); markdown += `\n`; }); } if (exportData.skills.length > 0) { markdown += `## ğŸš€ æŠ€èƒ½æˆé•¿\n\n`; const skillsByCategory = { 'focus': [], 'want': [], 'completed': [] }; exportData.skills.forEach(skill => { skillsByCategory[skill.category] = skillsByCategory[skill.category] || []; skillsByCategory[skill.category].push(skill); }); if (skillsByCategory.focus.length > 0) { markdown += `### ğŸ”¥ è¿‘æœŸé‡ç‚¹\n\n`; skillsByCategory.focus.forEach(skill => { const uniqueDays = new Set(skill.checkins.map(checkin => checkin.date)).size; const progress = Math.min(uniqueDays, 100); markdown += `#### [[${skill.name}]]\n\n`; markdown += `- **è¿›åº¦**: ${progress}/100å¤©\n`; markdown += `- **æ‰“å¡æ¬¡æ•°**: ${skill.checkins.length}æ¬¡\n\n`; if (skill.checkins.length > 0) { markdown += `**æœ€è¿‘æ‰“å¡è®°å½•ï¼š**\n\n`; skill.checkins.slice(0, 5).forEach(checkin => { markdown += `- ${checkin.date}ï¼š${checkin.content}\n`; }); if (skill.checkins.length > 5) { markdown += `*...è¿˜æœ‰ ${skill.checkins.length - 5} æ¡è®°å½•*\n`; } } markdown += '\n'; }); } if (skillsByCategory.want.length > 0) { markdown += `### ğŸ’­ æƒ³å­¦æŠ€èƒ½\n\n`; skillsByCategory.want.forEach(skill => { const uniqueDays = new Set(skill.checkins.map(checkin => checkin.date)).size; markdown += `- [[${skill.name}]] - ${uniqueDays}å¤©è¿›åº¦\n`; }); markdown += '\n'; } if (skillsByCategory.completed.length > 0) { markdown += `### âœ… å·²å®ŒæˆæŠ€èƒ½\n\n`; skillsByCategory.completed.forEach(skill => { markdown += `- [[${skill.name}]] - å·²å®Œæˆ ${skill.checkins.length} æ¬¡æ‰“å¡\n`; }); markdown += '\n'; } } if (exportData.reflections.length > 0) { markdown += `## ğŸ’­ è‡ªæˆ‘å¯¹è¯\n\n`; const { grouped: reflectionsByDate } = groupItemsByDate(exportData.reflections); Object.keys(reflectionsByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => { markdown += `### ${date}\n\n`; reflectionsByDate[date].forEach((reflection, index) => { const lines = reflection.text.split('\n'); const title = lines[0] || 'æœªå‘½ååæ€'; const content = lines.slice(1).join('\n'); markdown += `#### ${title}\n\n`; if (content.trim()) { markdown += `${content}\n\n`; } markdown += `_è®°å½•æ—¶é—´: ${reflection.time}_\n`; if (reflection.modificationHistory && reflection.modificationHistory.length > 0) { markdown += `- ä¿®æ”¹è®°å½•: ${reflection.modificationHistory.map(mod => `${mod.date} ${mod.time}`).join(', ')}\n`; } markdown += `\n`; }); }); } if (exportData.valueOutputs.length > 0) { markdown += `## ğŸ’ åˆ›é€ ä»·å€¼\n\n`; const outputsByCategory = {}; exportData.valueOutputs.forEach(output => { if (!outputsByCategory[output.category]) { outputsByCategory[output.category] = []; } outputsByCategory[output.category].push(output); }); Object.keys(outputsByCategory).forEach(category => { markdown += `### ${category}\n\n`; const outputsByDate = {}; outputsByCategory[category].forEach(output => { if (!outputsByDate[output.date]) { outputsByDate[output.date] = []; } outputsByDate[output.date].push(output); }); Object.keys(outputsByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => { markdown += `#### ${date}\n\n`; outputsByDate[date].forEach((output, index) => { markdown += `${index + 1}. ${output.text} _${output.time}_\n`; if (output.modificationHistory && output.modificationHistory.length > 0) { markdown += ` - ä¿®æ”¹è®°å½•: ${output.modificationHistory.map(mod => `${mod.date} ${mod.time}`).join(', ')}\n`; } }); markdown += `\n`; }); }); } markdown += `## ğŸ”— ç›¸å…³é“¾æ¥\n\n`; markdown += `- [[æ­£åé¦ˆæˆé•¿ç³»ç»Ÿ]] - æ ¸å¿ƒæ–¹æ³•è®º\n`; markdown += `- [[ä¸ªäººå‘å±•ä»ªè¡¨æ¿]] - æ•´ä½“è¿›åº¦\n`; markdown += `- [[æŠ€èƒ½æˆé•¿åœ°å›¾]] - æŠ€èƒ½å‘å±•è·¯å¾„\n`; if (dateRange.earliest) { markdown += `- [[${dateRange.earliest.substring(0,4)}å¹´æˆé•¿æ€»ç»“]] - å¹´åº¦å›é¡¾\n\n`; } markdown += `## ğŸ”„ è‡ªåŠ¨é“¾æ¥\n\n`; markdown += `- æŠ€èƒ½è¿½è¸ª:: ${counts.skills}é¡¹æŠ€èƒ½æ­£åœ¨æˆé•¿ä¸­\n`; markdown += `- æˆå°±ç»Ÿè®¡:: å·²è®°å½•${counts.achievements}ä¸ªæˆå°±æ—¶åˆ»\n`; markdown += `- åæ€å®è·µ:: ${counts.reflections}æ¬¡æ·±åº¦æ€è€ƒ\n`; markdown += `- ä»·å€¼åˆ›é€ :: ${counts.valueOutputs}æ¬¡ä»·å€¼è¾“å‡º\n\n`; markdown += `## ğŸ·ï¸ æ ‡ç­¾\n\n`; if (dateRange.earliest) { markdown += `#æ­£åé¦ˆ #æˆé•¿è®°å½• #ä¸ªäººå‘å±• #æˆå°±è¿½è¸ª #${dateRange.earliest.substring(0,4)}å¹´\n\n`; } else { markdown += `#æ­£åé¦ˆ #æˆé•¿è®°å½• #ä¸ªäººå‘å±• #æˆå°±è¿½è¸ª\n\n`; } markdown += `## ğŸ“‚ åˆ†ç±»\n\n`; if (counts.achievements > 0) markdown += `#æˆå°±è®°å½• `; if (counts.skills > 0) markdown += `#æŠ€èƒ½æˆé•¿ `; if (counts.reflections > 0) markdown += `#è‡ªæˆ‘åæ€ `; if (counts.valueOutputs > 0) markdown += `#ä»·å€¼åˆ›é€ \n`; return markdown; } function getSkillCategoryName(category) { const categoryNames = { 'want': 'æƒ³å­¦', 'focus': 'è¿‘æœŸé‡ç‚¹', 'completed': 'å·²å®Œæˆ' }; return categoryNames[category] || category; } function downloadEnhancedData() { const exportData = generateExportData(); let dataStr, mimeType, fileExtension; if (currentExportFormat === 'json') { dataStr = JSON.stringify(exportData, null, 2); mimeType = 'application/json'; fileExtension = 'json'; } else { dataStr = generateMarkdownData(exportData); mimeType = 'text/markdown;charset=utf-8'; fileExtension = 'md'; } const dateRange = getExportDateRange(exportData); const counts = getExportCounts(exportData); let fileName = 'æ­£åé¦ˆ'; fileName += `_${dateRange.display}`; if (currentExportFormat === 'json') { fileName += `_${counts.achievements}æˆå°±+${counts.skills}æŠ€èƒ½+${counts.reflections}åæ€+${counts.valueOutputs}åˆ›é€ .json`; } else { fileName += `_${counts.achievements}ach+${counts.skills}skl+${counts.reflections}ref+${counts.valueOutputs}val.md`; } const blob = new Blob([dataStr], { type: mimeType }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = fileName; link.style.display = 'none'; document.body.appendChild(link); link.click(); setTimeout(() => { document.body.removeChild(link); URL.revokeObjectURL(url); }, 100); closeModal('enhanced-export-modal'); } function showEnhancedImportModal() { document.getElementById('import-files').value = ''; document.getElementById('import-preview').style.display = 'none'; document.getElementById('import-progress').style.display = 'none'; document.getElementById('import-results').innerHTML = ''; document.getElementById('start-import-btn').disabled = true; document.getElementById('enhanced-import-modal').style.display = 'flex'; const fileInput = document.getElementById('import-files'); fileInput.onchange = null; fileInput.addEventListener('change', function(event) { const files = event.target.files; if (files.length === 0) return; const file = files[0]; const reader = new FileReader(); reader.onload = function(e) { try { const importedData = JSON.parse(e.target.result); if (isValidDataFormat(importedData)) { generateImportPreview(importedData); showImportPreview(importedData, file.name); } else { throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®'); } } catch (error) { alert('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message); console.error('å¯¼å…¥é”™è¯¯:', error); } }; reader.onerror = function() { alert('æ–‡ä»¶è¯»å–å¤±è´¥'); }; reader.readAsText(file); }); } function showImportPreview(importedData, filename) { const preview = document.getElementById('import-preview'); const startBtn = document.getElementById('start-import-btn'); window.pendingImportData = importedData; updateImportPreview(importedData); preview.style.display = 'block'; startBtn.disabled = false; document.getElementById('import-all-achievements').addEventListener('change', function() { const checkboxes = document.querySelectorAll('#import-achievements-details input[type="checkbox"]'); checkboxes.forEach(checkbox => checkbox.checked = this.checked); updateImportPreview(importedData); }); document.getElementById('import-all-skills').addEventListener('change', function() { const checkboxes = document.querySelectorAll('#import-skills-details input[type="checkbox"]'); checkboxes.forEach(checkbox => checkbox.checked = this.checked); updateImportPreview(importedData); }); document.getElementById('import-all-reflections').addEventListener('change', function() { const checkboxes = document.querySelectorAll('#import-reflections-details input[type="checkbox"]'); checkboxes.forEach(checkbox => checkbox.checked = this.checked); updateImportPreview(importedData); }); document.getElementById('import-all-value').addEventListener('change', function() { const checkboxes = document.querySelectorAll('#import-value-details input[type="checkbox"]'); checkboxes.forEach(checkbox => checkbox.checked = this.checked); updateImportPreview(importedData); }); } function updateImportPreview(importedData) { let totalCount = 0; let selectedData = { achievements: [], skills: [], reflections: [], valueOutputs: [] }; if (importedData.achievements) { const dateCheckboxes = document.querySelectorAll('#import-achievements-details input[type="checkbox"]:checked'); if (dateCheckboxes.length > 0) { const selectedDates = Array.from(dateCheckboxes).map(cb => cb.dataset.date); selectedData.achievements = importedData.achievements.filter(item => selectedDates.includes(item.date) ); } totalCount += selectedData.achievements.length; } if (importedData.skills) { const skillCheckboxes = document.querySelectorAll('#import-skills-details input[type="checkbox"]:checked'); if (skillCheckboxes.length > 0) { const selectedSkills = Array.from(skillCheckboxes).map(cb => parseInt(cb.dataset.skillId)); selectedData.skills = importedData.skills.filter(skill => selectedSkills.includes(skill.id) ); } totalCount += selectedData.skills.length; } if (importedData.reflections) { const dateCheckboxes = document.querySelectorAll('#import-reflections-details input[type="checkbox"]:checked'); if (dateCheckboxes.length > 0) { const selectedDates = Array.from(dateCheckboxes).map(cb => cb.dataset.date); selectedData.reflections = importedData.reflections.filter(item => selectedDates.includes(item.date) ); } totalCount += selectedData.reflections.length; } if (importedData.valueOutputs) { const categoryCheckboxes = document.querySelectorAll('#import-value-details input[type="checkbox"]:checked'); if (categoryCheckboxes.length > 0) { const selectedCategories = Array.from(categoryCheckboxes).map(cb => cb.dataset.category); selectedData.valueOutputs = importedData.valueOutputs.filter(item => selectedCategories.includes(item.category) ); } totalCount += selectedData.valueOutputs.length; } const dataSize = JSON.stringify(selectedData).length / 1024; document.getElementById('import-total-count').textContent = totalCount; document.getElementById('import-total-size').textContent = dataSize.toFixed(2); window.selectedImportData = selectedData; } function generateImportPreview(importedData) { if (importedData.achievements && importedData.achievements.length > 0) { document.getElementById('import-achievements-count').textContent = importedData.achievements.length; const { grouped: achievementsByDate } = groupItemsByDate(importedData.achievements); let achievementsHTML = ''; Object.keys(achievementsByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => { achievementsHTML += ` <label style="display: flex; align-items: center; justify-content: space-between; margin: 2px 0;"> <span>${date} (${achievementsByDate[date].length}æ¡)</span> <input type="checkbox" data-date="${date}" checked> </label> `; }); document.getElementById('import-achievements-details').innerHTML = achievementsHTML; } else { document.getElementById('import-achievements-count').textContent = '0'; document.getElementById('import-achievements-details').innerHTML = ''; } if (importedData.skills && importedData.skills.length > 0) { document.getElementById('import-skills-count').textContent = importedData.skills.length; let skillsHTML = ''; importedData.skills.forEach(skill => { const checkinCount = skill.checkins ? skill.checkins.length : 0; skillsHTML += ` <label style="display: flex; align-items: center; justify-content: space-between; margin: 2px 0;"> <span>${skill.name} (${checkinCount}æ¬¡æ‰“å¡)</span> <input type="checkbox" data-skill-id="${skill.id}" checked> </label> `; }); document.getElementById('import-skills-details').innerHTML = skillsHTML; } else { document.getElementById('import-skills-count').textContent = '0'; document.getElementById('import-skills-details').innerHTML = ''; } if (importedData.reflections && importedData.reflections.length > 0) { document.getElementById('import-reflections-count').textContent = importedData.reflections.length; const { grouped: reflectionsByDate } = groupItemsByDate(importedData.reflections); let reflectionsHTML = ''; Object.keys(reflectionsByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => { reflectionsHTML += ` <label style="display: flex; align-items: center; justify-content: space-between; margin: 2px 0;"> <span>${date} (${reflectionsByDate[date].length}æ¡)</span> <input type="checkbox" data-date="${date}" checked> </label> `; }); document.getElementById('import-reflections-details').innerHTML = reflectionsHTML; } else { document.getElementById('import-reflections-count').textContent = '0'; document.getElementById('import-reflections-details').innerHTML = ''; } if (importedData.valueOutputs && importedData.valueOutputs.length > 0) { document.getElementById('import-value-count').textContent = importedData.valueOutputs.length; const valueByCategory = {}; importedData.valueOutputs.forEach(output => { if (!valueByCategory[output.category]) { valueByCategory[output.category] = []; } valueByCategory[output.category].push(output); }); let valueHTML = ''; Object.keys(valueByCategory).forEach(category => { valueHTML += ` <label style="display: flex; align-items: center; justify-content: space-between; margin: 2px 0;"> <span>${category} (${valueByCategory[category].length}æ¡)</span> <input type="checkbox" data-category="${category}" checked> </label> `; }); document.getElementById('import-value-details').innerHTML = valueHTML; } else { document.getElementById('import-value-count').textContent = '0'; document.getElementById('import-value-details').innerHTML = ''; } setTimeout(() => { document.querySelectorAll('#import-preview input[type="checkbox"]').forEach(checkbox => { checkbox.addEventListener('change', () => { updateImportPreview(importedData); updateAllCheckboxState(); }); }); updateAllCheckboxState(); }, 100); } function updateAllCheckboxState() { const achievementCheckboxes = document.querySelectorAll('#import-achievements-details input[type="checkbox"]'); const allAchievementsChecked = achievementCheckboxes.length > 0 && Array.from(achievementCheckboxes).every(cb => cb.checked); document.getElementById('import-all-achievements').checked = allAchievementsChecked; const skillCheckboxes = document.querySelectorAll('#import-skills-details input[type="checkbox"]'); const allSkillsChecked = skillCheckboxes.length > 0 && Array.from(skillCheckboxes).every(cb => cb.checked); document.getElementById('import-all-skills').checked = allSkillsChecked; const reflectionCheckboxes = document.querySelectorAll('#import-reflections-details input[type="checkbox"]'); const allReflectionsChecked = reflectionCheckboxes.length > 0 && Array.from(reflectionCheckboxes).every(cb => cb.checked); document.getElementById('import-all-reflections').checked = allReflectionsChecked; const valueCheckboxes = document.querySelectorAll('#import-value-details input[type="checkbox"]'); const allValueChecked = valueCheckboxes.length > 0 && Array.from(valueCheckboxes).every(cb => cb.checked); document.getElementById('import-all-value').checked = allValueChecked; } function importMultipleData() { const importedData = window.selectedImportData; if (!importedData) { alert('è¯·å…ˆé€‰æ‹©è¦å¯¼å…¥çš„æ•°æ®'); return; } const totalCount = importedData.achievements.length + importedData.skills.length + importedData.reflections.length + importedData.valueOutputs.length; if (totalCount === 0) { alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªåˆ†ç±»è¿›è¡Œå¯¼å…¥'); return; } const success = mergeImportedData(importedData, 'é€‰æ‹©çš„æ–‡ä»¶'); if (success) { closeModal('enhanced-import-modal'); } } function processFilesSequentially(files, index, importResults) { if (index >= files.length) { showImportResults(importResults); return; } const file = files[index]; const reader = new FileReader(); reader.onload = function(e) { try { const importedData = JSON.parse(e.target.result); if (isValidDataFormat(importedData)) { const success = mergeImportedData(importedData, file.name); if (success) { importResults.success++; importResults.details.push({ filename: file.name, status: 'æˆåŠŸ', message: `å¯¼å…¥ ${getDataSummary(importedData)}` }); } else { importResults.failed++; importResults.details.push({ filename: file.name, status: 'å–æ¶ˆ', message: 'ç”¨æˆ·å–æ¶ˆäº†å¯¼å…¥' }); } } else { throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®'); } } catch (error) { importResults.failed++; importResults.details.push({ filename: file.name, status: 'å¤±è´¥', message: error.message }); } updateImportProgress(index + 1, files.length); processFilesSequentially(files, index + 1, importResults); }; reader.onerror = function() { importResults.failed++; importResults.details.push({ filename: file.name, status: 'å¤±è´¥', message: 'æ–‡ä»¶è¯»å–å¤±è´¥' }); updateImportProgress(index + 1, files.length); processFilesSequentially(files, index + 1, importResults); }; reader.readAsText(file); } function isValidDataFormat(data) { if (typeof data !== 'object') return false; try { if (!data.achievements || !Array.isArray(data.achievements)) return false; if (!data.skills || !Array.isArray(data.skills)) return false; if (!data.reflections || !Array.isArray(data.reflections)) return false; if (!data.valueOutputs || !Array.isArray(data.valueOutputs)) return false; if (data.achievements.length > 0) { const firstAchievement = data.achievements[0]; if (!firstAchievement.text || !firstAchievement.date) return false; } return true; } catch (e) { return false; } } function getDataSummary(data) { const parts = []; if (data.achievements) parts.push(`${data.achievements.length} æ¡æˆå°±`); if (data.skills) parts.push(`${data.skills.length} é¡¹æŠ€èƒ½`); if (data.reflections) parts.push(`${data.reflections.length} æ¡åæ€`); if (data.valueOutputs) parts.push(`${data.valueOutputs.length} æ¡ä»·å€¼è¾“å‡º`); return parts.join(', '); } function updateImportProgress(current, total) { const progressPercent = (current / total) * 100; document.getElementById('import-progress-bar').style.width = `${progressPercent}%`; document.getElementById('import-progress-text').textContent = `å¤„ç†ä¸­... ${current}/${total}`; } function showImportResults(results) { const resultsContainer = document.getElementById('import-results'); resultsContainer.innerHTML = ''; results.details.forEach(detail => { const resultItem = document.createElement('div'); resultItem.className = 'import-result-item'; resultItem.innerHTML = ` <div class="${detail.status === 'æˆåŠŸ' ? 'import-success' : 'import-failure'}"> <strong>${detail.filename}</strong> - ${detail.status}: ${detail.message} </div> `; resultsContainer.appendChild(resultItem); }); const summary = document.createElement('div'); summary.className = 'import-result-item'; summary.innerHTML = `<strong>æ±‡æ€»: æˆåŠŸ ${results.success}/${results.total}, å¤±è´¥ ${results.failed}/${results.total}</strong>`; resultsContainer.appendChild(summary); renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); updateStats(); if (results.failed === 0) { closeModal('enhanced-import-modal'); } } function validateAndFixImportedData(importedData) { if (Array.isArray(importedData.achievements)) { importedData.achievements.forEach(achievement => { if (!achievement.timestamp || achievement.timestamp instanceof Date) { achievement.timestamp = fixMissingTimestamp(achievement.date, achievement.time); } if (typeof achievement.timestamp !== 'number') { achievement.timestamp = parseInt(achievement.timestamp) || new Date().getTime(); } }); } if (Array.isArray(importedData.reflections)) { importedData.reflections.forEach(reflection => { if (!reflection.timestamp || reflection.timestamp instanceof Date) { reflection.timestamp = fixMissingTimestamp(reflection.date, reflection.time); } if (typeof reflection.timestamp !== 'number') { reflection.timestamp = parseInt(reflection.timestamp) || new Date().getTime(); } }); } if (Array.isArray(importedData.valueOutputs)) { importedData.valueOutputs.forEach(valueOutput => { if (!valueOutput.timestamp || valueOutput.timestamp instanceof Date) { valueOutput.timestamp = fixMissingTimestamp(valueOutput.date, valueOutput.time); } if (typeof valueOutput.timestamp !== 'number') { valueOutput.timestamp = parseInt(valueOutput.timestamp) || new Date().getTime(); } }); } if (Array.isArray(importedData.skills)) { importedData.skills.forEach(skill => { if (Array.isArray(skill.checkins)) { skill.checkins.forEach(checkin => { if (!checkin.timestamp || checkin.timestamp instanceof Date) { checkin.timestamp = fixMissingTimestamp(checkin.date, checkin.time); } if (typeof checkin.timestamp !== 'number') { checkin.timestamp = parseInt(checkin.timestamp) || new Date().getTime(); } }); } }); } } function mergeImportedData(importedData, filename = 'å¯¼å…¥æ–‡ä»¶') { validateAndFixImportedData(importedData); const importStats = { achievements: Array.isArray(importedData.achievements) ? importedData.achievements.length : 0, skills: Array.isArray(importedData.skills) ? importedData.skills.length : 0, reflections: Array.isArray(importedData.reflections) ? importedData.reflections.length : 0, valueOutputs: Array.isArray(importedData.valueOutputs) ? importedData.valueOutputs.length : 0, recordDays: importedData.recordData ? importedData.recordData.recordDays : 0 }; if (Array.isArray(importedData.achievements)) { const existingAchievementIds = new Set(appData.achievements.map(a => a.id)); let addedAchievements = 0; importedData.achievements.forEach(achievement => { if (!existingAchievementIds.has(achievement.id)) { appData.achievements.push(achievement); addedAchievements++; } }); console.log(`å¯¼å…¥äº† ${addedAchievements} æ¡æ–°æˆå°±è®°å½•`); } if (Array.isArray(importedData.skills)) { const existingSkillIds = new Set(appData.skills.map(s => s.id)); let addedSkills = 0; let addedCheckins = 0; importedData.skills.forEach(skill => { if (!existingSkillIds.has(skill.id)) { appData.skills.push(skill); addedSkills++; } else { const existingSkill = appData.skills.find(s => s.id === skill.id); const existingCheckinIds = new Set(existingSkill.checkins.map(c => c.id)); skill.checkins.forEach(checkin => { if (!existingCheckinIds.has(checkin.id)) { existingSkill.checkins.push(checkin); addedCheckins++; } }); } }); console.log(`å¯¼å…¥äº† ${addedSkills} é¡¹æ–°æŠ€èƒ½ï¼Œ${addedCheckins} æ¡æ‰“å¡è®°å½•`); } if (Array.isArray(importedData.reflections)) { const existingReflectionIds = new Set(appData.reflections.map(r => r.id)); let addedReflections = 0; importedData.reflections.forEach(reflection => { if (!existingReflectionIds.has(reflection.id)) { appData.reflections.push(reflection); addedReflections++; } }); console.log(`å¯¼å…¥äº† ${addedReflections} æ¡æ–°åæ€è®°å½•`); } if (Array.isArray(importedData.valueOutputs)) { const existingValueOutputIds = new Set(appData.valueOutputs.map(v => v.id)); let addedValueOutputs = 0; importedData.valueOutputs.forEach(valueOutput => { if (!existingValueOutputIds.has(valueOutput.id)) { appData.valueOutputs.push(valueOutput); addedValueOutputs++; } }); console.log(`å¯¼å…¥äº† ${addedValueOutputs} æ¡æ–°ä»·å€¼è¾“å‡ºè®°å½•`); } if (importedData.recordData && Array.isArray(importedData.recordData.recordDates)) { const importedRecordDates = new Set(importedData.recordData.recordDates); appData.recordData.recordDates.forEach(date => importedRecordDates.add(date)); appData.recordData.recordDates = Array.from(importedRecordDates); appData.recordData.recordDays = appData.recordData.recordDates.length; } appData.achievements.sort((a, b) => { const timeA = a.timestamp || new Date(a.date + ' ' + a.time).getTime(); const timeB = b.timestamp || new Date(b.date + ' ' + b.time).getTime(); return timeB - timeA; }); appData.reflections.sort((a, b) => { const timeA = a.timestamp || new Date(a.date).getTime(); const timeB = b.timestamp || new Date(b.date).getTime(); return timeB - timeA; }); appData.valueOutputs.sort((a, b) => { const timeA = a.timestamp || new Date(a.date).getTime(); const timeB = b.timestamp || new Date(b.date).getTime(); return timeB - timeA; }); appData.skills.forEach(skill => { skill.checkins.sort((a, b) => { const timeA = a.timestamp || new Date(a.date).getTime(); const timeB = b.timestamp || new Date(b.date).getTime(); return timeB - timeA; }); }); checkRecordDays(); saveData(); renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); updateStats(); updateSearchStatus(); return true; } function resetData() { document.getElementById('reset-password').value = ''; document.getElementById('password-error').style.display = 'none'; document.getElementById('reset-modal').style.display = 'flex'; const dateRange = getDateRange(); document.getElementById('reset-start-date').value = dateRange.earliest; document.getElementById('reset-end-date').value = dateRange.latest; document.getElementById('reset-all-dates').checked = true; document.querySelectorAll('.reset-category-checkbox').forEach(checkbox => { checkbox.checked = true; }); updateResetSummary(); document.querySelectorAll('.reset-category-checkbox').forEach(checkbox => { checkbox.addEventListener('change', updateResetSummary); }); document.getElementById('reset-start-date').addEventListener('change', updateResetSummary); document.getElementById('reset-end-date').addEventListener('change', updateResetSummary); document.getElementById('reset-all-dates').addEventListener('change', function() { const dateInputs = document.querySelectorAll('#reset-start-date, #reset-end-date'); dateInputs.forEach(input => input.disabled = this.checked); updateResetSummary(); }); document.querySelectorAll('#reset-start-date, #reset-end-date').forEach(input => { input.disabled = true; }); } function updateResetSummary() { const resetAchievements = document.getElementById('reset-achievements').checked; const resetSkills = document.getElementById('reset-skills').checked; const resetReflections = document.getElementById('reset-reflections').checked; const resetValue = document.getElementById('reset-value').checked; const resetAllDates = document.getElementById('reset-all-dates').checked; let startDate, endDate; if (!resetAllDates) { startDate = document.getElementById('reset-start-date').value; endDate = document.getElementById('reset-end-date').value; } let totalCount = 0; const details = []; if (resetAchievements) { const achievements = getRecordsToDelete(appData.achievements, startDate, endDate, resetAllDates); totalCount += achievements.length; if (achievements.length > 0) { details.push(`æ¯æ—¥æˆå°±: ${achievements.length} æ¡`); } } if (resetSkills) { let skillCount = 0; let checkinCount = 0; appData.skills.forEach(skill => { const checkins = getRecordsToDelete(skill.checkins, startDate, endDate, resetAllDates); if (checkins.length > 0) { skillCount++; checkinCount += checkins.length; } }); totalCount += checkinCount; if (skillCount > 0) { details.push(`æŠ€èƒ½æˆé•¿: ${skillCount} é¡¹æŠ€èƒ½ï¼Œ${checkinCount} æ¬¡æ‰“å¡`); } } if (resetReflections) { const reflections = getRecordsToDelete(appData.reflections, startDate, endDate, resetAllDates); totalCount += reflections.length; if (reflections.length > 0) { details.push(`è‡ªæˆ‘å¯¹è¯: ${reflections.length} æ¡`); } } if (resetValue) { const valueOutputs = getRecordsToDelete(appData.valueOutputs, startDate, endDate, resetAllDates); totalCount += valueOutputs.length; if (valueOutputs.length > 0) { details.push(`åˆ›é€ ä»·å€¼: ${valueOutputs.length} æ¡`); } } const estimatedSize = (totalCount * 0.5).toFixed(2); const detailsHTML = details.length > 0 ? details.map(detail => `<p>â€¢ ${detail}</p>`).join('') : '<p>è¯·é€‰æ‹©è¦é‡ç½®çš„åˆ†ç±»...</p>'; document.getElementById('reset-details').innerHTML = detailsHTML; document.getElementById('reset-total-count').textContent = totalCount; document.getElementById('reset-total-size').textContent = estimatedSize; document.getElementById('confirm-reset-btn').disabled = totalCount === 0; } function getRecordsToDelete(records, startDate, endDate, allDates) { if (!records || records.length === 0) return []; if (allDates) { return records; } if (!startDate || !endDate) { return []; } const start = new Date(startDate); const end = new Date(endDate); end.setHours(23, 59, 59, 999); return filterByDateRange(records, startDate, endDate); } function confirmResetData() { const password = document.getElementById('reset-password').value;
         
		 
		 const correctPassword = '11111';
		 
		 
         
  if (password !== correctPassword) { document.getElementById('password-error').style.display = 'block'; document.getElementById('reset-password').value = ''; document.getElementById('reset-password').focus(); return; } const resetAchievements = document.getElementById('reset-achievements').checked; const resetSkills = document.getElementById('reset-skills').checked; const resetReflections = document.getElementById('reset-reflections').checked; const resetValue = document.getElementById('reset-value').checked; const resetAllDates = document.getElementById('reset-all-dates').checked; let startDate, endDate; if (!resetAllDates) { startDate = document.getElementById('reset-start-date').value; endDate = document.getElementById('reset-end-date').value; } let resetCount = 0; if (resetAchievements) { if (resetAllDates) { resetCount += appData.achievements.length; appData.achievements = []; } else { const remaining = appData.achievements.filter(record => { const recordDate = new Date(record.date); const start = new Date(startDate); const end = new Date(endDate); end.setHours(23, 59, 59, 999); return recordDate < start || recordDate > end; }); resetCount += (appData.achievements.length - remaining.length); appData.achievements = remaining; } } if (resetSkills) { appData.skills.forEach(skill => { if (resetAllDates) { resetCount += skill.checkins.length; skill.checkins = []; } else { const remainingCheckins = skill.checkins.filter(checkin => { const checkinDate = new Date(checkin.date); const start = new Date(startDate); const end = new Date(endDate); end.setHours(23, 59, 59, 999); return checkinDate < start || checkinDate > end; }); resetCount += (skill.checkins.length - remainingCheckins.length); skill.checkins = remainingCheckins; } }); appData.skills = appData.skills.filter(skill => skill.checkins.length > 0); } if (resetReflections) { if (resetAllDates) { resetCount += appData.reflections.length; appData.reflections = []; } else { const remaining = appData.reflections.filter(record => { const recordDate = new Date(record.date); const start = new Date(startDate); const end = new Date(endDate); end.setHours(23, 59, 59, 999); return recordDate < start || recordDate > end; }); resetCount += (appData.reflections.length - remaining.length); appData.reflections = remaining; } } if (resetValue) { if (resetAllDates) { resetCount += appData.valueOutputs.length; appData.valueOutputs = []; } else { const remaining = appData.valueOutputs.filter(record => { const recordDate = new Date(record.date); const start = new Date(startDate); const end = new Date(endDate); end.setHours(23, 59, 59, 999); return recordDate < start || recordDate > end; }); resetCount += (appData.valueOutputs.length - remaining.length); appData.valueOutputs = remaining; } } checkRecordDays(); saveData(); clearSearch(); renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); updateStats(); if (appData.achievements.length === 0) { document.getElementById('achievements-list').innerHTML = ''; } if (appData.skills.length === 0) { document.getElementById('skills-list').innerHTML = ''; } if (appData.reflections.length === 0) { document.getElementById('reflection-list').innerHTML = ''; } if (appData.valueOutputs.length === 0) { document.getElementById('value-outputs-list').innerHTML = ''; } closeModal('reset-modal'); } function performSearch() { const searchInput = document.getElementById('search-input'); searchKeyword = searchInput.value.trim(); renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); updateSearchStatus(); } function showDateFilterModal() { document.getElementById('date-filter-modal').style.display = 'flex'; renderCalendar(); } document.addEventListener('DOMContentLoaded', function() { const dateFilterTabs = document.querySelectorAll('.date-filter-tab'); const dateFilterContents = document.querySelectorAll('.date-filter-content'); dateFilterTabs.forEach(tab => { tab.addEventListener('click', function() { dateFilterTabs.forEach(t => t.classList.remove('active')); this.classList.add('active'); dateFilterContents.forEach(content => content.classList.remove('active')); const filterType = this.getAttribute('data-filter-type'); document.getElementById(`date-filter-${filterType}`).classList.add('active'); if (filterType === 'day') { renderCalendar(); } }); }); const skillCategoryButtons = document.querySelectorAll('.skill-category-button'); skillCategoryButtons.forEach(button => { button.addEventListener('click', function() { skillCategoryButtons.forEach(btn => btn.classList.remove('active')); this.classList.add('active'); skillCategoryFilter = this.getAttribute('data-category'); renderSkills(); }); }); }); function renderCalendar() { const container = document.getElementById('calendar-container'); container.innerHTML = ''; const recordDates = getAllRecordDates(); const months = {}; recordDates.forEach(dateStr => { const date = new Date(dateStr); const year = date.getFullYear(); const month = date.getMonth(); const key = `${year}-${month}`; if (!months[key]) { months[key] = { year: year, month: month, dates: [] }; } months[key].dates.push(date.getDate()); }); Object.values(months).forEach(monthData => { const monthDiv = document.createElement('div'); monthDiv.className = 'calendar-month'; const monthHeader = document.createElement('div'); monthHeader.className = 'calendar-month-header'; monthHeader.textContent = `${monthData.year}å¹´${monthData.month + 1}æœˆ`; monthDiv.appendChild(monthHeader); const weekdaysDiv = document.createElement('div'); weekdaysDiv.className = 'calendar-weekdays'; ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'].forEach(day => { const dayDiv = document.createElement('div'); dayDiv.textContent = day; weekdaysDiv.appendChild(dayDiv); }); monthDiv.appendChild(weekdaysDiv); const daysDiv = document.createElement('div'); daysDiv.className = 'calendar-days'; const firstDay = new Date(monthData.year, monthData.month, 1).getDay(); for (let i = 0; i < firstDay; i++) { const emptyDay = document.createElement('div'); emptyDay.className = 'calendar-day empty'; daysDiv.appendChild(emptyDay); } const daysInMonth = new Date(monthData.year, monthData.month + 1, 0).getDate(); for (let day = 1; day <= daysInMonth; day++) { const dayDiv = document.createElement('div'); dayDiv.className = 'calendar-day'; dayDiv.textContent = day; if (monthData.dates.includes(day)) { dayDiv.classList.add('recorded'); } dayDiv.addEventListener('click', function() { const selectedDate = new Date(monthData.year, monthData.month, day); dateFilter = selectedDate.toLocaleDateString(); renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); closeModal('date-filter-modal'); }); daysDiv.appendChild(dayDiv); } monthDiv.appendChild(daysDiv); container.appendChild(monthDiv); }); }function applyDateFilter(type) { let dateFilterValue; switch(type) { case 'day': const dateInput = document.getElementById('date-filter-input'); const selectedDate = dateInput.value; if (!selectedDate) { alert('è¯·é€‰æ‹©æ—¥æœŸ'); return; } const filterDate = new Date(selectedDate); dateFilterValue = filterDate.toLocaleDateString(); break; case 'month': const monthInput = document.getElementById('month-filter-input'); const selectedMonth = monthInput.value; if (!selectedMonth) { alert('è¯·é€‰æ‹©æœˆä»½'); return; } dateFilterValue = { type: 'month', value: selectedMonth }; break; case 'year': const yearInput = document.getElementById('year-filter-input'); const selectedYear = yearInput.value; if (!selectedYear) { alert('è¯·é€‰æ‹©å¹´ä»½'); return; } dateFilterValue = { type: 'year', value: selectedYear }; break; case 'range': const startDateInput = document.getElementById('start-date-input'); const endDateInput = document.getElementById('end-date-input'); const startDate = startDateInput.value; const endDate = endDateInput.value; if (!startDate || !endDate) { alert('è¯·é€‰æ‹©å¼€å§‹æ—¥æœŸå’Œç»“æŸæ—¥æœŸ'); return; } if (new Date(startDate) > new Date(endDate)) { alert('å¼€å§‹æ—¥æœŸä¸èƒ½æ™šäºç»“æŸæ—¥æœŸ'); return; } dateFilterValue = { type: 'range', start: startDate, end: endDate }; break; default: return; } dateFilter = dateFilterValue; renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); closeModal('date-filter-modal'); updateSearchStatus();} function clearDateFilter() { dateFilter = ''; renderAchievements(); renderSkills(); renderReflections(); renderValueOutputs(); closeModal('date-filter-modal'); updateSearchStatus(); } function showReminderModal() { const settings = appData.reminderSettings; document.getElementById('enable-reminder').checked = settings.enabled; if (settings.type === 'weekly') { document.querySelector('input[name="reminder-type"][value="weekly"]').checked = true; document.getElementById('reminder-weekday').value = settings.day; } else { document.querySelector('input[name="reminder-type"][value="monthly"]').checked = true; document.getElementById('reminder-day').value = settings.day; } const daySelect = document.getElementById('reminder-day'); daySelect.innerHTML = ''; for (let i = 1; i <= 31; i++) { const option = document.createElement('option'); option.value = i; option.textContent = i + 'å·'; daySelect.appendChild(option); } toggleReminderDetails(); toggleReminderType(); document.getElementById('reminder-modal').style.display = 'flex'; } function toggleReminderDetails() { const enableReminder = document.getElementById('enable-reminder').checked; document.getElementById('reminder-details').style.display = enableReminder ? 'block' : 'none'; } function toggleReminderType() { const reminderType = document.querySelector('input[name="reminder-type"]:checked').value; document.getElementById('weekly-reminder').style.display = reminderType === 'weekly' ? 'block' : 'none'; document.getElementById('monthly-reminder').style.display = reminderType === 'monthly' ? 'block' : 'none'; } function saveReminderSettings() { const enabled = document.getElementById('enable-reminder').checked; const type = document.querySelector('input[name="reminder-type"]:checked').value; let day; if (type === 'weekly') { day = parseInt(document.getElementById('reminder-weekday').value); } else { day = parseInt(document.getElementById('reminder-day').value); } appData.reminderSettings = { enabled: enabled, type: type, day: day, lastReminded: appData.reminderSettings.lastReminded }; saveData(); closeModal('reminder-modal'); if (enabled) { alert('æé†’è®¾ç½®å·²ä¿å­˜ï¼'); } else { alert('æé†’å·²å…³é—­'); } } document.addEventListener('DOMContentLoaded', function() { const valueButtons = document.querySelectorAll('.value-category-button'); const valueInputAreas = document.querySelectorAll('.value-input-area'); valueButtons.forEach(button => { button.addEventListener('click', function() { valueButtons.forEach(btn => btn.classList.remove('active')); this.classList.add('active'); valueInputAreas.forEach(area => area.classList.remove('active')); const category = this.getAttribute('data-category'); document.getElementById(`value-input-${category}`).classList.add('active'); }); }); }); function checkFirstUse() { if (!localStorage.getItem('privacyAccepted')) { document.getElementById('privacy-modal').style.display = 'flex'; }}function acceptPrivacy() { localStorage.setItem('privacyAccepted', 'true'); document.getElementById('privacy-modal').style.display = 'none';} window.onload = function() { checkFirstUse(); loadData();const header = document.getElementById('main-header');if (!header.classList.contains('reminder')) { const slogans = [ 'è®°å½•æˆé•¿ï¼Œå‘ç°æ›´å¥½çš„è‡ªå·±', 'ä¸“æ³¨è¿›æ­¥ï¼Œè€Œéå®Œç¾' ]; const randomIndex = Math.floor(Math.random() * slogans.length); document.getElementById('random-slogan').textContent = slogans[randomIndex];} const dateFilterTabs = document.querySelectorAll('.date-filter-tab'); const dateFilterContents = document.querySelectorAll('.date-filter-content'); dateFilterTabs.forEach(tab => { tab.addEventListener('click', function() { dateFilterTabs.forEach(t => t.classList.remove('active')); this.classList.add('active'); dateFilterContents.forEach(content => content.classList.remove('active')); const filterType = this.getAttribute('data-filter-type'); document.getElementById(`date-filter-${filterType}`).classList.add('active'); if (filterType === 'day') { renderCalendar(); } }); }); const skillCategoryButtons = document.querySelectorAll('.skill-category-button'); skillCategoryButtons.forEach(button => { button.addEventListener('click', function() { skillCategoryButtons.forEach(btn => btn.classList.remove('active')); this.classList.add('active'); skillCategoryFilter = this.getAttribute('data-category'); renderSkills(); }); }); const valueButtons = document.querySelectorAll('.value-category-button'); const valueInputAreas = document.querySelectorAll('.value-input-area'); valueButtons.forEach(button => { button.addEventListener('click', function() { valueButtons.forEach(btn => btn.classList.remove('active')); this.classList.add('active'); valueInputAreas.forEach(area => area.classList.remove('active')); const category = this.getAttribute('data-category'); document.getElementById(`value-input-${category}`).classList.add('active'); }); }); };
        // =============================================
        // æ­£åé¦ˆæˆé•¿åŠ©æ‰‹
        // ä½œè€…ï¼šåŠ±å°åŠ  Â© 2025
        // è®¸å¯è¯ï¼šGPLv3 - https://www.gnu.org/licenses/gpl-3.0.html
        // æºä»£ç ï¼šhttps://github.com/li-xiao-jia/positive-feedback-assistant  
        // æ”¯æŒä½œè€…ï¼šhttps://space.bilibili.com/557858654
        // =============================================
    </script>
   </body>
</html>
